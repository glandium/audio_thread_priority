/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const TRUE: ::std::os::raw::c_uint = 1;
pub const FALSE: ::std::os::raw::c_uint = 0;
pub const BYTE_SIZE: ::std::os::raw::c_uint = 8;
pub const I386_PGBYTES: ::std::os::raw::c_uint = 4096;
pub const I386_PGSHIFT: ::std::os::raw::c_uint = 12;
pub const PAGE_SIZE: ::std::os::raw::c_uint = 4096;
pub const PAGE_SHIFT: ::std::os::raw::c_uint = 12;
pub const PAGE_MASK: ::std::os::raw::c_uint = 4095;
pub const PAGE_MAX_SHIFT: ::std::os::raw::c_uint = 12;
pub const PAGE_MAX_SIZE: ::std::os::raw::c_uint = 4096;
pub const PAGE_MAX_MASK: ::std::os::raw::c_uint = 4095;
pub const PAGE_MIN_SHIFT: ::std::os::raw::c_uint = 12;
pub const PAGE_MIN_SIZE: ::std::os::raw::c_uint = 4096;
pub const PAGE_MIN_MASK: ::std::os::raw::c_uint = 4095;
pub const I386_LPGBYTES: ::std::os::raw::c_uint = 2097152;
pub const I386_LPGSHIFT: ::std::os::raw::c_uint = 21;
pub const I386_LPGMASK: ::std::os::raw::c_uint = 2097151;
pub const MACH_PORT_NULL: ::std::os::raw::c_uint = 0;
pub const MACH_PORT_TYPE_DNREQUEST: ::std::os::raw::c_uint = 2147483648;
pub const MACH_PORT_TYPE_SPREQUEST: ::std::os::raw::c_uint = 1073741824;
pub const MACH_PORT_TYPE_SPREQUEST_DELAYED: ::std::os::raw::c_uint = 536870912;
pub const MACH_PORT_SRIGHTS_NONE: ::std::os::raw::c_uint = 0;
pub const MACH_PORT_SRIGHTS_PRESENT: ::std::os::raw::c_uint = 1;
pub const MACH_PORT_QLIMIT_ZERO: ::std::os::raw::c_uint = 0;
pub const MACH_PORT_QLIMIT_BASIC: ::std::os::raw::c_uint = 5;
pub const MACH_PORT_QLIMIT_SMALL: ::std::os::raw::c_uint = 16;
pub const MACH_PORT_QLIMIT_LARGE: ::std::os::raw::c_uint = 1024;
pub const MACH_PORT_QLIMIT_KERNEL: ::std::os::raw::c_uint = 65534;
pub const MACH_PORT_QLIMIT_MIN: ::std::os::raw::c_uint = 0;
pub const MACH_PORT_QLIMIT_DEFAULT: ::std::os::raw::c_uint = 5;
pub const MACH_PORT_QLIMIT_MAX: ::std::os::raw::c_uint = 1024;
pub const MACH_PORT_STATUS_FLAG_TEMPOWNER: ::std::os::raw::c_uint = 1;
pub const MACH_PORT_STATUS_FLAG_GUARDED: ::std::os::raw::c_uint = 2;
pub const MACH_PORT_STATUS_FLAG_STRICT_GUARD: ::std::os::raw::c_uint = 4;
pub const MACH_PORT_STATUS_FLAG_IMP_DONATION: ::std::os::raw::c_uint = 8;
pub const MACH_PORT_STATUS_FLAG_REVIVE: ::std::os::raw::c_uint = 16;
pub const MACH_PORT_STATUS_FLAG_TASKPTR: ::std::os::raw::c_uint = 32;
pub const MACH_PORT_LIMITS_INFO: ::std::os::raw::c_uint = 1;
pub const MACH_PORT_RECEIVE_STATUS: ::std::os::raw::c_uint = 2;
pub const MACH_PORT_DNREQUESTS_SIZE: ::std::os::raw::c_uint = 3;
pub const MACH_PORT_TEMPOWNER: ::std::os::raw::c_uint = 4;
pub const MACH_PORT_IMPORTANCE_RECEIVER: ::std::os::raw::c_uint = 5;
pub const MACH_PORT_DENAP_RECEIVER: ::std::os::raw::c_uint = 6;
pub const MACH_PORT_INFO_EXT: ::std::os::raw::c_uint = 7;
pub const MACH_PORT_DNREQUESTS_SIZE_COUNT: ::std::os::raw::c_uint = 1;
pub const MPO_CONTEXT_AS_GUARD: ::std::os::raw::c_uint = 1;
pub const MPO_QLIMIT: ::std::os::raw::c_uint = 2;
pub const MPO_TEMPOWNER: ::std::os::raw::c_uint = 4;
pub const MPO_IMPORTANCE_RECEIVER: ::std::os::raw::c_uint = 8;
pub const MPO_INSERT_SEND_RIGHT: ::std::os::raw::c_uint = 16;
pub const MPO_STRICT: ::std::os::raw::c_uint = 32;
pub const MPO_DENAP_RECEIVER: ::std::os::raw::c_uint = 64;
pub const GUARD_TYPE_MACH_PORT: ::std::os::raw::c_uint = 1;
pub const KERN_SUCCESS: ::std::os::raw::c_uint = 0;
pub const KERN_INVALID_ADDRESS: ::std::os::raw::c_uint = 1;
pub const KERN_PROTECTION_FAILURE: ::std::os::raw::c_uint = 2;
pub const KERN_NO_SPACE: ::std::os::raw::c_uint = 3;
pub const KERN_INVALID_ARGUMENT: ::std::os::raw::c_uint = 4;
pub const KERN_FAILURE: ::std::os::raw::c_uint = 5;
pub const KERN_RESOURCE_SHORTAGE: ::std::os::raw::c_uint = 6;
pub const KERN_NOT_RECEIVER: ::std::os::raw::c_uint = 7;
pub const KERN_NO_ACCESS: ::std::os::raw::c_uint = 8;
pub const KERN_MEMORY_FAILURE: ::std::os::raw::c_uint = 9;
pub const KERN_MEMORY_ERROR: ::std::os::raw::c_uint = 10;
pub const KERN_ALREADY_IN_SET: ::std::os::raw::c_uint = 11;
pub const KERN_NOT_IN_SET: ::std::os::raw::c_uint = 12;
pub const KERN_NAME_EXISTS: ::std::os::raw::c_uint = 13;
pub const KERN_ABORTED: ::std::os::raw::c_uint = 14;
pub const KERN_INVALID_NAME: ::std::os::raw::c_uint = 15;
pub const KERN_INVALID_TASK: ::std::os::raw::c_uint = 16;
pub const KERN_INVALID_RIGHT: ::std::os::raw::c_uint = 17;
pub const KERN_INVALID_VALUE: ::std::os::raw::c_uint = 18;
pub const KERN_UREFS_OVERFLOW: ::std::os::raw::c_uint = 19;
pub const KERN_INVALID_CAPABILITY: ::std::os::raw::c_uint = 20;
pub const KERN_RIGHT_EXISTS: ::std::os::raw::c_uint = 21;
pub const KERN_INVALID_HOST: ::std::os::raw::c_uint = 22;
pub const KERN_MEMORY_PRESENT: ::std::os::raw::c_uint = 23;
pub const KERN_MEMORY_DATA_MOVED: ::std::os::raw::c_uint = 24;
pub const KERN_MEMORY_RESTART_COPY: ::std::os::raw::c_uint = 25;
pub const KERN_INVALID_PROCESSOR_SET: ::std::os::raw::c_uint = 26;
pub const KERN_POLICY_LIMIT: ::std::os::raw::c_uint = 27;
pub const KERN_INVALID_POLICY: ::std::os::raw::c_uint = 28;
pub const KERN_INVALID_OBJECT: ::std::os::raw::c_uint = 29;
pub const KERN_ALREADY_WAITING: ::std::os::raw::c_uint = 30;
pub const KERN_DEFAULT_SET: ::std::os::raw::c_uint = 31;
pub const KERN_EXCEPTION_PROTECTED: ::std::os::raw::c_uint = 32;
pub const KERN_INVALID_LEDGER: ::std::os::raw::c_uint = 33;
pub const KERN_INVALID_MEMORY_CONTROL: ::std::os::raw::c_uint = 34;
pub const KERN_INVALID_SECURITY: ::std::os::raw::c_uint = 35;
pub const KERN_NOT_DEPRESSED: ::std::os::raw::c_uint = 36;
pub const KERN_TERMINATED: ::std::os::raw::c_uint = 37;
pub const KERN_LOCK_SET_DESTROYED: ::std::os::raw::c_uint = 38;
pub const KERN_LOCK_UNSTABLE: ::std::os::raw::c_uint = 39;
pub const KERN_LOCK_OWNED: ::std::os::raw::c_uint = 40;
pub const KERN_LOCK_OWNED_SELF: ::std::os::raw::c_uint = 41;
pub const KERN_SEMAPHORE_DESTROYED: ::std::os::raw::c_uint = 42;
pub const KERN_RPC_SERVER_TERMINATED: ::std::os::raw::c_uint = 43;
pub const KERN_RPC_TERMINATE_ORPHAN: ::std::os::raw::c_uint = 44;
pub const KERN_RPC_CONTINUE_ORPHAN: ::std::os::raw::c_uint = 45;
pub const KERN_NOT_SUPPORTED: ::std::os::raw::c_uint = 46;
pub const KERN_NODE_DOWN: ::std::os::raw::c_uint = 47;
pub const KERN_NOT_WAITING: ::std::os::raw::c_uint = 48;
pub const KERN_OPERATION_TIMED_OUT: ::std::os::raw::c_uint = 49;
pub const KERN_CODESIGN_ERROR: ::std::os::raw::c_uint = 50;
pub const KERN_POLICY_STATIC: ::std::os::raw::c_uint = 51;
pub const KERN_INSUFFICIENT_BUFFER_SIZE: ::std::os::raw::c_uint = 52;
pub const KERN_RETURN_MAX: ::std::os::raw::c_uint = 256;
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __MAC_10_11: ::std::os::raw::c_uint = 101100;
pub const __MAC_10_11_2: ::std::os::raw::c_uint = 101102;
pub const __MAC_10_11_3: ::std::os::raw::c_uint = 101103;
pub const __MAC_10_11_4: ::std::os::raw::c_uint = 101104;
pub const __MAC_10_12: ::std::os::raw::c_uint = 101200;
pub const __MAC_10_12_1: ::std::os::raw::c_uint = 101201;
pub const __MAC_10_12_2: ::std::os::raw::c_uint = 101202;
pub const __MAC_10_12_4: ::std::os::raw::c_uint = 101204;
pub const __MAC_10_13: ::std::os::raw::c_uint = 101300;
pub const __MAC_10_13_1: ::std::os::raw::c_uint = 101301;
pub const __MAC_10_13_2: ::std::os::raw::c_uint = 101302;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __IPHONE_8_1: ::std::os::raw::c_uint = 80100;
pub const __IPHONE_8_2: ::std::os::raw::c_uint = 80200;
pub const __IPHONE_8_3: ::std::os::raw::c_uint = 80300;
pub const __IPHONE_8_4: ::std::os::raw::c_uint = 80400;
pub const __IPHONE_9_0: ::std::os::raw::c_uint = 90000;
pub const __IPHONE_9_1: ::std::os::raw::c_uint = 90100;
pub const __IPHONE_9_2: ::std::os::raw::c_uint = 90200;
pub const __IPHONE_9_3: ::std::os::raw::c_uint = 90300;
pub const __IPHONE_10_0: ::std::os::raw::c_uint = 100000;
pub const __IPHONE_10_1: ::std::os::raw::c_uint = 100100;
pub const __IPHONE_10_2: ::std::os::raw::c_uint = 100200;
pub const __IPHONE_10_3: ::std::os::raw::c_uint = 100300;
pub const __IPHONE_11_0: ::std::os::raw::c_uint = 110000;
pub const __IPHONE_11_1: ::std::os::raw::c_uint = 110100;
pub const __IPHONE_11_2: ::std::os::raw::c_uint = 110200;
pub const __TVOS_9_0: ::std::os::raw::c_uint = 90000;
pub const __TVOS_9_1: ::std::os::raw::c_uint = 90100;
pub const __TVOS_9_2: ::std::os::raw::c_uint = 90200;
pub const __TVOS_10_0: ::std::os::raw::c_uint = 100000;
pub const __TVOS_10_0_1: ::std::os::raw::c_uint = 100001;
pub const __TVOS_10_1: ::std::os::raw::c_uint = 100100;
pub const __TVOS_10_2: ::std::os::raw::c_uint = 100200;
pub const __TVOS_11_0: ::std::os::raw::c_uint = 110000;
pub const __TVOS_11_1: ::std::os::raw::c_uint = 110100;
pub const __TVOS_11_2: ::std::os::raw::c_uint = 110200;
pub const __WATCHOS_1_0: ::std::os::raw::c_uint = 10000;
pub const __WATCHOS_2_0: ::std::os::raw::c_uint = 20000;
pub const __WATCHOS_2_1: ::std::os::raw::c_uint = 20100;
pub const __WATCHOS_2_2: ::std::os::raw::c_uint = 20200;
pub const __WATCHOS_3_0: ::std::os::raw::c_uint = 30000;
pub const __WATCHOS_3_1: ::std::os::raw::c_uint = 30100;
pub const __WATCHOS_3_1_1: ::std::os::raw::c_uint = 30101;
pub const __WATCHOS_3_2: ::std::os::raw::c_uint = 30200;
pub const __WATCHOS_4_0: ::std::os::raw::c_uint = 40000;
pub const __WATCHOS_4_1: ::std::os::raw::c_uint = 40100;
pub const __WATCHOS_4_2: ::std::os::raw::c_uint = 40200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101302;
pub const MACH_MSGH_BITS_ZERO: ::std::os::raw::c_uint = 0;
pub const MACH_MSGH_BITS_REMOTE_MASK: ::std::os::raw::c_uint = 31;
pub const MACH_MSGH_BITS_LOCAL_MASK: ::std::os::raw::c_uint = 7936;
pub const MACH_MSGH_BITS_VOUCHER_MASK: ::std::os::raw::c_uint = 2031616;
pub const MACH_MSGH_BITS_PORTS_MASK: ::std::os::raw::c_uint = 2039583;
pub const MACH_MSGH_BITS_COMPLEX: ::std::os::raw::c_uint = 2147483648;
pub const MACH_MSGH_BITS_USER: ::std::os::raw::c_uint = 2149523231;
pub const MACH_MSGH_BITS_RAISEIMP: ::std::os::raw::c_uint = 536870912;
pub const MACH_MSGH_BITS_DENAP: ::std::os::raw::c_uint = 536870912;
pub const MACH_MSGH_BITS_IMPHOLDASRT: ::std::os::raw::c_uint = 268435456;
pub const MACH_MSGH_BITS_DENAPHOLDASRT: ::std::os::raw::c_uint = 268435456;
pub const MACH_MSGH_BITS_CIRCULAR: ::std::os::raw::c_uint = 268435456;
pub const MACH_MSGH_BITS_USED: ::std::os::raw::c_uint = 2954829599;
pub const MACH_MSG_TYPE_MOVE_RECEIVE: ::std::os::raw::c_uint = 16;
pub const MACH_MSG_TYPE_MOVE_SEND: ::std::os::raw::c_uint = 17;
pub const MACH_MSG_TYPE_MOVE_SEND_ONCE: ::std::os::raw::c_uint = 18;
pub const MACH_MSG_TYPE_COPY_SEND: ::std::os::raw::c_uint = 19;
pub const MACH_MSG_TYPE_MAKE_SEND: ::std::os::raw::c_uint = 20;
pub const MACH_MSG_TYPE_MAKE_SEND_ONCE: ::std::os::raw::c_uint = 21;
pub const MACH_MSG_TYPE_COPY_RECEIVE: ::std::os::raw::c_uint = 22;
pub const MACH_MSG_TYPE_DISPOSE_RECEIVE: ::std::os::raw::c_uint = 24;
pub const MACH_MSG_TYPE_DISPOSE_SEND: ::std::os::raw::c_uint = 25;
pub const MACH_MSG_TYPE_DISPOSE_SEND_ONCE: ::std::os::raw::c_uint = 26;
pub const MACH_MSG_PHYSICAL_COPY: ::std::os::raw::c_uint = 0;
pub const MACH_MSG_VIRTUAL_COPY: ::std::os::raw::c_uint = 1;
pub const MACH_MSG_ALLOCATE: ::std::os::raw::c_uint = 2;
pub const MACH_MSG_OVERWRITE: ::std::os::raw::c_uint = 3;
pub const MACH_MSG_PORT_DESCRIPTOR: ::std::os::raw::c_uint = 0;
pub const MACH_MSG_OOL_DESCRIPTOR: ::std::os::raw::c_uint = 1;
pub const MACH_MSG_OOL_PORTS_DESCRIPTOR: ::std::os::raw::c_uint = 2;
pub const MACH_MSG_OOL_VOLATILE_DESCRIPTOR: ::std::os::raw::c_uint = 3;
pub const MACH_MSG_TRAILER_FORMAT_0: ::std::os::raw::c_uint = 0;
pub const MACH_MSGH_KIND_NORMAL: ::std::os::raw::c_uint = 0;
pub const MACH_MSGH_KIND_NOTIFICATION: ::std::os::raw::c_uint = 1;
pub const MACH_MSG_TYPE_PORT_NONE: ::std::os::raw::c_uint = 0;
pub const MACH_MSG_TYPE_PORT_NAME: ::std::os::raw::c_uint = 15;
pub const MACH_MSG_TYPE_PORT_RECEIVE: ::std::os::raw::c_uint = 16;
pub const MACH_MSG_TYPE_PORT_SEND: ::std::os::raw::c_uint = 17;
pub const MACH_MSG_TYPE_PORT_SEND_ONCE: ::std::os::raw::c_uint = 18;
pub const MACH_MSG_TYPE_LAST: ::std::os::raw::c_uint = 22;
pub const MACH_MSG_OPTION_NONE: ::std::os::raw::c_uint = 0;
pub const MACH_SEND_MSG: ::std::os::raw::c_uint = 1;
pub const MACH_RCV_MSG: ::std::os::raw::c_uint = 2;
pub const MACH_RCV_LARGE: ::std::os::raw::c_uint = 4;
pub const MACH_RCV_LARGE_IDENTITY: ::std::os::raw::c_uint = 8;
pub const MACH_SEND_TIMEOUT: ::std::os::raw::c_uint = 16;
pub const MACH_SEND_OVERRIDE: ::std::os::raw::c_uint = 32;
pub const MACH_SEND_INTERRUPT: ::std::os::raw::c_uint = 64;
pub const MACH_SEND_NOTIFY: ::std::os::raw::c_uint = 128;
pub const MACH_SEND_ALWAYS: ::std::os::raw::c_uint = 65536;
pub const MACH_SEND_TRAILER: ::std::os::raw::c_uint = 131072;
pub const MACH_SEND_NOIMPORTANCE: ::std::os::raw::c_uint = 262144;
pub const MACH_SEND_NODENAP: ::std::os::raw::c_uint = 262144;
pub const MACH_SEND_IMPORTANCE: ::std::os::raw::c_uint = 524288;
pub const MACH_SEND_SYNC_OVERRIDE: ::std::os::raw::c_uint = 1048576;
pub const MACH_RCV_TIMEOUT: ::std::os::raw::c_uint = 256;
pub const MACH_RCV_NOTIFY: ::std::os::raw::c_uint = 512;
pub const MACH_RCV_INTERRUPT: ::std::os::raw::c_uint = 1024;
pub const MACH_RCV_VOUCHER: ::std::os::raw::c_uint = 2048;
pub const MACH_RCV_OVERWRITE: ::std::os::raw::c_uint = 4096;
pub const MACH_RCV_SYNC_WAIT: ::std::os::raw::c_uint = 16384;
pub const MACH_RCV_TRAILER_NULL: ::std::os::raw::c_uint = 0;
pub const MACH_RCV_TRAILER_SEQNO: ::std::os::raw::c_uint = 1;
pub const MACH_RCV_TRAILER_SENDER: ::std::os::raw::c_uint = 2;
pub const MACH_RCV_TRAILER_AUDIT: ::std::os::raw::c_uint = 3;
pub const MACH_RCV_TRAILER_CTX: ::std::os::raw::c_uint = 4;
pub const MACH_RCV_TRAILER_AV: ::std::os::raw::c_uint = 7;
pub const MACH_RCV_TRAILER_LABELS: ::std::os::raw::c_uint = 8;
pub const MACH_RCV_TRAILER_MASK: ::std::os::raw::c_uint = 251658240;
pub const MACH_MSG_SUCCESS: ::std::os::raw::c_uint = 0;
pub const MACH_MSG_MASK: ::std::os::raw::c_uint = 15872;
pub const MACH_MSG_IPC_SPACE: ::std::os::raw::c_uint = 8192;
pub const MACH_MSG_VM_SPACE: ::std::os::raw::c_uint = 4096;
pub const MACH_MSG_IPC_KERNEL: ::std::os::raw::c_uint = 2048;
pub const MACH_MSG_VM_KERNEL: ::std::os::raw::c_uint = 1024;
pub const MACH_SEND_IN_PROGRESS: ::std::os::raw::c_uint = 268435457;
pub const MACH_SEND_INVALID_DATA: ::std::os::raw::c_uint = 268435458;
pub const MACH_SEND_INVALID_DEST: ::std::os::raw::c_uint = 268435459;
pub const MACH_SEND_TIMED_OUT: ::std::os::raw::c_uint = 268435460;
pub const MACH_SEND_INVALID_VOUCHER: ::std::os::raw::c_uint = 268435461;
pub const MACH_SEND_INTERRUPTED: ::std::os::raw::c_uint = 268435463;
pub const MACH_SEND_MSG_TOO_SMALL: ::std::os::raw::c_uint = 268435464;
pub const MACH_SEND_INVALID_REPLY: ::std::os::raw::c_uint = 268435465;
pub const MACH_SEND_INVALID_RIGHT: ::std::os::raw::c_uint = 268435466;
pub const MACH_SEND_INVALID_NOTIFY: ::std::os::raw::c_uint = 268435467;
pub const MACH_SEND_INVALID_MEMORY: ::std::os::raw::c_uint = 268435468;
pub const MACH_SEND_NO_BUFFER: ::std::os::raw::c_uint = 268435469;
pub const MACH_SEND_TOO_LARGE: ::std::os::raw::c_uint = 268435470;
pub const MACH_SEND_INVALID_TYPE: ::std::os::raw::c_uint = 268435471;
pub const MACH_SEND_INVALID_HEADER: ::std::os::raw::c_uint = 268435472;
pub const MACH_SEND_INVALID_TRAILER: ::std::os::raw::c_uint = 268435473;
pub const MACH_SEND_INVALID_RT_OOL_SIZE: ::std::os::raw::c_uint = 268435477;
pub const MACH_RCV_IN_PROGRESS: ::std::os::raw::c_uint = 268451841;
pub const MACH_RCV_INVALID_NAME: ::std::os::raw::c_uint = 268451842;
pub const MACH_RCV_TIMED_OUT: ::std::os::raw::c_uint = 268451843;
pub const MACH_RCV_TOO_LARGE: ::std::os::raw::c_uint = 268451844;
pub const MACH_RCV_INTERRUPTED: ::std::os::raw::c_uint = 268451845;
pub const MACH_RCV_PORT_CHANGED: ::std::os::raw::c_uint = 268451846;
pub const MACH_RCV_INVALID_NOTIFY: ::std::os::raw::c_uint = 268451847;
pub const MACH_RCV_INVALID_DATA: ::std::os::raw::c_uint = 268451848;
pub const MACH_RCV_PORT_DIED: ::std::os::raw::c_uint = 268451849;
pub const MACH_RCV_IN_SET: ::std::os::raw::c_uint = 268451850;
pub const MACH_RCV_HEADER_ERROR: ::std::os::raw::c_uint = 268451851;
pub const MACH_RCV_BODY_ERROR: ::std::os::raw::c_uint = 268451852;
pub const MACH_RCV_INVALID_TYPE: ::std::os::raw::c_uint = 268451853;
pub const MACH_RCV_SCATTER_SMALL: ::std::os::raw::c_uint = 268451854;
pub const MACH_RCV_INVALID_TRAILER: ::std::os::raw::c_uint = 268451855;
pub const MACH_RCV_IN_PROGRESS_TIMED: ::std::os::raw::c_uint = 268451857;
pub const VM_PAGE_QUERY_PAGE_PRESENT: ::std::os::raw::c_uint = 1;
pub const VM_PAGE_QUERY_PAGE_FICTITIOUS: ::std::os::raw::c_uint = 2;
pub const VM_PAGE_QUERY_PAGE_REF: ::std::os::raw::c_uint = 4;
pub const VM_PAGE_QUERY_PAGE_DIRTY: ::std::os::raw::c_uint = 8;
pub const VM_PAGE_QUERY_PAGE_PAGED_OUT: ::std::os::raw::c_uint = 16;
pub const VM_PAGE_QUERY_PAGE_COPIED: ::std::os::raw::c_uint = 32;
pub const VM_PAGE_QUERY_PAGE_SPECULATIVE: ::std::os::raw::c_uint = 64;
pub const VM_PAGE_QUERY_PAGE_EXTERNAL: ::std::os::raw::c_uint = 128;
pub const VM_PAGE_QUERY_PAGE_CS_VALIDATED: ::std::os::raw::c_uint = 256;
pub const VM_PAGE_QUERY_PAGE_CS_TAINTED: ::std::os::raw::c_uint = 512;
pub const VM_PAGE_QUERY_PAGE_CS_NX: ::std::os::raw::c_uint = 1024;
pub const VM_FLAGS_FIXED: ::std::os::raw::c_uint = 0;
pub const VM_FLAGS_ANYWHERE: ::std::os::raw::c_uint = 1;
pub const VM_FLAGS_PURGABLE: ::std::os::raw::c_uint = 2;
pub const VM_FLAGS_RANDOM_ADDR: ::std::os::raw::c_uint = 8;
pub const VM_FLAGS_NO_CACHE: ::std::os::raw::c_uint = 16;
pub const VM_FLAGS_RESILIENT_CODESIGN: ::std::os::raw::c_uint = 32;
pub const VM_FLAGS_RESILIENT_MEDIA: ::std::os::raw::c_uint = 64;
pub const VM_FLAGS_OVERWRITE: ::std::os::raw::c_uint = 16384;
pub const VM_FLAGS_SUPERPAGE_MASK: ::std::os::raw::c_uint = 458752;
pub const VM_FLAGS_RETURN_DATA_ADDR: ::std::os::raw::c_uint = 1048576;
pub const VM_FLAGS_RETURN_4K_DATA_ADDR: ::std::os::raw::c_uint = 8388608;
pub const VM_FLAGS_ALIAS_MASK: ::std::os::raw::c_uint = 4278190080;
pub const VM_FLAGS_USER_ALLOCATE: ::std::os::raw::c_uint = 4278665243;
pub const VM_FLAGS_USER_MAP: ::std::os::raw::c_uint = 4288102427;
pub const VM_FLAGS_USER_REMAP: ::std::os::raw::c_uint = 1065001;
pub const VM_FLAGS_SUPERPAGE_SHIFT: ::std::os::raw::c_uint = 16;
pub const SUPERPAGE_NONE: ::std::os::raw::c_uint = 0;
pub const SUPERPAGE_SIZE_ANY: ::std::os::raw::c_uint = 1;
pub const VM_FLAGS_SUPERPAGE_NONE: ::std::os::raw::c_uint = 0;
pub const VM_FLAGS_SUPERPAGE_SIZE_ANY: ::std::os::raw::c_uint = 65536;
pub const SUPERPAGE_SIZE_2MB: ::std::os::raw::c_uint = 2;
pub const VM_FLAGS_SUPERPAGE_SIZE_2MB: ::std::os::raw::c_uint = 131072;
pub const VM_MEMORY_MALLOC: ::std::os::raw::c_uint = 1;
pub const VM_MEMORY_MALLOC_SMALL: ::std::os::raw::c_uint = 2;
pub const VM_MEMORY_MALLOC_LARGE: ::std::os::raw::c_uint = 3;
pub const VM_MEMORY_MALLOC_HUGE: ::std::os::raw::c_uint = 4;
pub const VM_MEMORY_SBRK: ::std::os::raw::c_uint = 5;
pub const VM_MEMORY_REALLOC: ::std::os::raw::c_uint = 6;
pub const VM_MEMORY_MALLOC_TINY: ::std::os::raw::c_uint = 7;
pub const VM_MEMORY_MALLOC_LARGE_REUSABLE: ::std::os::raw::c_uint = 8;
pub const VM_MEMORY_MALLOC_LARGE_REUSED: ::std::os::raw::c_uint = 9;
pub const VM_MEMORY_ANALYSIS_TOOL: ::std::os::raw::c_uint = 10;
pub const VM_MEMORY_MALLOC_NANO: ::std::os::raw::c_uint = 11;
pub const VM_MEMORY_MACH_MSG: ::std::os::raw::c_uint = 20;
pub const VM_MEMORY_IOKIT: ::std::os::raw::c_uint = 21;
pub const VM_MEMORY_STACK: ::std::os::raw::c_uint = 30;
pub const VM_MEMORY_GUARD: ::std::os::raw::c_uint = 31;
pub const VM_MEMORY_SHARED_PMAP: ::std::os::raw::c_uint = 32;
pub const VM_MEMORY_DYLIB: ::std::os::raw::c_uint = 33;
pub const VM_MEMORY_OBJC_DISPATCHERS: ::std::os::raw::c_uint = 34;
pub const VM_MEMORY_UNSHARED_PMAP: ::std::os::raw::c_uint = 35;
pub const VM_MEMORY_APPKIT: ::std::os::raw::c_uint = 40;
pub const VM_MEMORY_FOUNDATION: ::std::os::raw::c_uint = 41;
pub const VM_MEMORY_COREGRAPHICS: ::std::os::raw::c_uint = 42;
pub const VM_MEMORY_CORESERVICES: ::std::os::raw::c_uint = 43;
pub const VM_MEMORY_CARBON: ::std::os::raw::c_uint = 43;
pub const VM_MEMORY_JAVA: ::std::os::raw::c_uint = 44;
pub const VM_MEMORY_COREDATA: ::std::os::raw::c_uint = 45;
pub const VM_MEMORY_COREDATA_OBJECTIDS: ::std::os::raw::c_uint = 46;
pub const VM_MEMORY_ATS: ::std::os::raw::c_uint = 50;
pub const VM_MEMORY_LAYERKIT: ::std::os::raw::c_uint = 51;
pub const VM_MEMORY_CGIMAGE: ::std::os::raw::c_uint = 52;
pub const VM_MEMORY_TCMALLOC: ::std::os::raw::c_uint = 53;
pub const VM_MEMORY_COREGRAPHICS_DATA: ::std::os::raw::c_uint = 54;
pub const VM_MEMORY_COREGRAPHICS_SHARED: ::std::os::raw::c_uint = 55;
pub const VM_MEMORY_COREGRAPHICS_FRAMEBUFFERS: ::std::os::raw::c_uint = 56;
pub const VM_MEMORY_COREGRAPHICS_BACKINGSTORES: ::std::os::raw::c_uint = 57;
pub const VM_MEMORY_COREGRAPHICS_XALLOC: ::std::os::raw::c_uint = 58;
pub const VM_MEMORY_COREGRAPHICS_MISC: ::std::os::raw::c_uint = 42;
pub const VM_MEMORY_DYLD: ::std::os::raw::c_uint = 60;
pub const VM_MEMORY_DYLD_MALLOC: ::std::os::raw::c_uint = 61;
pub const VM_MEMORY_SQLITE: ::std::os::raw::c_uint = 62;
pub const VM_MEMORY_JAVASCRIPT_CORE: ::std::os::raw::c_uint = 63;
pub const VM_MEMORY_WEBASSEMBLY: ::std::os::raw::c_uint = 63;
pub const VM_MEMORY_JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR: ::std::os::raw::c_uint = 64;
pub const VM_MEMORY_JAVASCRIPT_JIT_REGISTER_FILE: ::std::os::raw::c_uint = 65;
pub const VM_MEMORY_GLSL: ::std::os::raw::c_uint = 66;
pub const VM_MEMORY_OPENCL: ::std::os::raw::c_uint = 67;
pub const VM_MEMORY_COREIMAGE: ::std::os::raw::c_uint = 68;
pub const VM_MEMORY_WEBCORE_PURGEABLE_BUFFERS: ::std::os::raw::c_uint = 69;
pub const VM_MEMORY_IMAGEIO: ::std::os::raw::c_uint = 70;
pub const VM_MEMORY_COREPROFILE: ::std::os::raw::c_uint = 71;
pub const VM_MEMORY_ASSETSD: ::std::os::raw::c_uint = 72;
pub const VM_MEMORY_OS_ALLOC_ONCE: ::std::os::raw::c_uint = 73;
pub const VM_MEMORY_LIBDISPATCH: ::std::os::raw::c_uint = 74;
pub const VM_MEMORY_ACCELERATE: ::std::os::raw::c_uint = 75;
pub const VM_MEMORY_COREUI: ::std::os::raw::c_uint = 76;
pub const VM_MEMORY_COREUIFILE: ::std::os::raw::c_uint = 77;
pub const VM_MEMORY_GENEALOGY: ::std::os::raw::c_uint = 78;
pub const VM_MEMORY_RAWCAMERA: ::std::os::raw::c_uint = 79;
pub const VM_MEMORY_CORPSEINFO: ::std::os::raw::c_uint = 80;
pub const VM_MEMORY_ASL: ::std::os::raw::c_uint = 81;
pub const VM_MEMORY_SWIFT_RUNTIME: ::std::os::raw::c_uint = 82;
pub const VM_MEMORY_SWIFT_METADATA: ::std::os::raw::c_uint = 83;
pub const VM_MEMORY_DHMM: ::std::os::raw::c_uint = 84;
pub const VM_MEMORY_SCENEKIT: ::std::os::raw::c_uint = 86;
pub const VM_MEMORY_SKYWALK: ::std::os::raw::c_uint = 87;
pub const VM_MEMORY_IOSURFACE: ::std::os::raw::c_uint = 88;
pub const VM_MEMORY_LIBNETWORK: ::std::os::raw::c_uint = 89;
pub const VM_MEMORY_AUDIO: ::std::os::raw::c_uint = 90;
pub const VM_MEMORY_VIDEOBITSTREAM: ::std::os::raw::c_uint = 91;
pub const VM_MEMORY_APPLICATION_SPECIFIC_1: ::std::os::raw::c_uint = 240;
pub const VM_MEMORY_APPLICATION_SPECIFIC_16: ::std::os::raw::c_uint = 255;
pub const CPU_STATE_MAX: ::std::os::raw::c_uint = 4;
pub const CPU_STATE_USER: ::std::os::raw::c_uint = 0;
pub const CPU_STATE_SYSTEM: ::std::os::raw::c_uint = 1;
pub const CPU_STATE_IDLE: ::std::os::raw::c_uint = 2;
pub const CPU_STATE_NICE: ::std::os::raw::c_uint = 3;
pub const CPU_ARCH_MASK: ::std::os::raw::c_uint = 4278190080;
pub const CPU_ARCH_ABI64: ::std::os::raw::c_uint = 16777216;
pub const CPU_SUBTYPE_MASK: ::std::os::raw::c_uint = 4278190080;
pub const CPU_SUBTYPE_LIB64: ::std::os::raw::c_uint = 2147483648;
pub const CPU_SUBTYPE_INTEL_FAMILY_MAX: ::std::os::raw::c_uint = 15;
pub const CPU_SUBTYPE_INTEL_MODEL_ALL: ::std::os::raw::c_uint = 0;
pub const CPUFAMILY_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const CPUFAMILY_POWERPC_G3: ::std::os::raw::c_uint = 3471054153;
pub const CPUFAMILY_POWERPC_G4: ::std::os::raw::c_uint = 2009171118;
pub const CPUFAMILY_POWERPC_G5: ::std::os::raw::c_uint = 3983988906;
pub const CPUFAMILY_INTEL_6_13: ::std::os::raw::c_uint = 2855483691;
pub const CPUFAMILY_INTEL_PENRYN: ::std::os::raw::c_uint = 2028621756;
pub const CPUFAMILY_INTEL_NEHALEM: ::std::os::raw::c_uint = 1801080018;
pub const CPUFAMILY_INTEL_WESTMERE: ::std::os::raw::c_uint = 1463508716;
pub const CPUFAMILY_INTEL_SANDYBRIDGE: ::std::os::raw::c_uint = 1418770316;
pub const CPUFAMILY_INTEL_IVYBRIDGE: ::std::os::raw::c_uint = 526772277;
pub const CPUFAMILY_INTEL_HASWELL: ::std::os::raw::c_uint = 280134364;
pub const CPUFAMILY_INTEL_BROADWELL: ::std::os::raw::c_uint = 1479463068;
pub const CPUFAMILY_INTEL_SKYLAKE: ::std::os::raw::c_uint = 939270559;
pub const CPUFAMILY_INTEL_KABYLAKE: ::std::os::raw::c_uint = 260141638;
pub const CPUFAMILY_ARM_9: ::std::os::raw::c_uint = 3878847406;
pub const CPUFAMILY_ARM_11: ::std::os::raw::c_uint = 2415272152;
pub const CPUFAMILY_ARM_XSCALE: ::std::os::raw::c_uint = 1404044789;
pub const CPUFAMILY_ARM_12: ::std::os::raw::c_uint = 3172666089;
pub const CPUFAMILY_ARM_13: ::std::os::raw::c_uint = 214503012;
pub const CPUFAMILY_ARM_14: ::std::os::raw::c_uint = 2517073649;
pub const CPUFAMILY_ARM_15: ::std::os::raw::c_uint = 2823887818;
pub const CPUFAMILY_ARM_SWIFT: ::std::os::raw::c_uint = 506291073;
pub const CPUFAMILY_ARM_CYCLONE: ::std::os::raw::c_uint = 933271106;
pub const CPUFAMILY_ARM_TYPHOON: ::std::os::raw::c_uint = 747742334;
pub const CPUFAMILY_ARM_TWISTER: ::std::os::raw::c_uint = 2465937352;
pub const CPUFAMILY_ARM_HURRICANE: ::std::os::raw::c_uint = 1741614739;
pub const CPUFAMILY_ARM_MONSOON_MISTRAL: ::std::os::raw::c_uint = 3894312694;
pub const CPUFAMILY_INTEL_6_23: ::std::os::raw::c_uint = 2028621756;
pub const CPUFAMILY_INTEL_6_26: ::std::os::raw::c_uint = 1801080018;
pub const TIME_MICROS_MAX: ::std::os::raw::c_uint = 1000000;
pub const HOST_INFO_MAX: ::std::os::raw::c_uint = 1024;
pub const KERNEL_VERSION_MAX: ::std::os::raw::c_uint = 512;
pub const KERNEL_BOOT_INFO_MAX: ::std::os::raw::c_uint = 4096;
pub const HOST_BASIC_INFO: ::std::os::raw::c_uint = 1;
pub const HOST_SCHED_INFO: ::std::os::raw::c_uint = 3;
pub const HOST_RESOURCE_SIZES: ::std::os::raw::c_uint = 4;
pub const HOST_PRIORITY_INFO: ::std::os::raw::c_uint = 5;
pub const HOST_SEMAPHORE_TRAPS: ::std::os::raw::c_uint = 7;
pub const HOST_MACH_MSG_TRAP: ::std::os::raw::c_uint = 8;
pub const HOST_VM_PURGABLE: ::std::os::raw::c_uint = 9;
pub const HOST_DEBUG_INFO_INTERNAL: ::std::os::raw::c_uint = 10;
pub const HOST_CAN_HAS_DEBUGGER: ::std::os::raw::c_uint = 11;
pub const HOST_LOAD_INFO: ::std::os::raw::c_uint = 1;
pub const HOST_VM_INFO: ::std::os::raw::c_uint = 2;
pub const HOST_CPU_LOAD_INFO: ::std::os::raw::c_uint = 3;
pub const HOST_VM_INFO64: ::std::os::raw::c_uint = 4;
pub const HOST_EXTMOD_INFO64: ::std::os::raw::c_uint = 5;
pub const HOST_EXPIRED_TASK_INFO: ::std::os::raw::c_uint = 6;
pub const HOST_NOTIFY_CALENDAR_CHANGE: ::std::os::raw::c_uint = 0;
pub const HOST_NOTIFY_CALENDAR_SET: ::std::os::raw::c_uint = 1;
pub const HOST_NOTIFY_TYPE_MAX: ::std::os::raw::c_uint = 1;
pub const HOST_CALENDAR_CHANGED_REPLYID: ::std::os::raw::c_uint = 950;
pub const HOST_CALENDAR_SET_REPLYID: ::std::os::raw::c_uint = 951;
pub const HOST_SECURITY_PORT: ::std::os::raw::c_uint = 0;
pub const HOST_PORT: ::std::os::raw::c_uint = 1;
pub const HOST_PRIV_PORT: ::std::os::raw::c_uint = 2;
pub const HOST_IO_MASTER_PORT: ::std::os::raw::c_uint = 3;
pub const HOST_MAX_SPECIAL_KERNEL_PORT: ::std::os::raw::c_uint = 7;
pub const HOST_DYNAMIC_PAGER_PORT: ::std::os::raw::c_uint = 8;
pub const HOST_AUDIT_CONTROL_PORT: ::std::os::raw::c_uint = 9;
pub const HOST_USER_NOTIFICATION_PORT: ::std::os::raw::c_uint = 10;
pub const HOST_AUTOMOUNTD_PORT: ::std::os::raw::c_uint = 11;
pub const HOST_LOCKD_PORT: ::std::os::raw::c_uint = 12;
pub const HOST_KTRACE_BACKGROUND_PORT: ::std::os::raw::c_uint = 13;
pub const HOST_SEATBELT_PORT: ::std::os::raw::c_uint = 14;
pub const HOST_KEXTD_PORT: ::std::os::raw::c_uint = 15;
pub const HOST_CHUD_PORT: ::std::os::raw::c_uint = 16;
pub const HOST_UNFREED_PORT: ::std::os::raw::c_uint = 17;
pub const HOST_AMFID_PORT: ::std::os::raw::c_uint = 18;
pub const HOST_GSSD_PORT: ::std::os::raw::c_uint = 19;
pub const HOST_TELEMETRY_PORT: ::std::os::raw::c_uint = 20;
pub const HOST_ATM_NOTIFICATION_PORT: ::std::os::raw::c_uint = 21;
pub const HOST_COALITION_PORT: ::std::os::raw::c_uint = 22;
pub const HOST_SYSDIAGNOSE_PORT: ::std::os::raw::c_uint = 23;
pub const HOST_XPC_EXCEPTION_PORT: ::std::os::raw::c_uint = 24;
pub const HOST_CONTAINERD_PORT: ::std::os::raw::c_uint = 25;
pub const HOST_NODE_PORT: ::std::os::raw::c_uint = 26;
pub const HOST_RESOURCE_NOTIFY_PORT: ::std::os::raw::c_uint = 27;
pub const HOST_CLOSURED_PORT: ::std::os::raw::c_uint = 28;
pub const HOST_MAX_SPECIAL_PORT: ::std::os::raw::c_uint = 28;
pub const HOST_LOCAL_NODE: ::std::os::raw::c_int = -1;
pub const PPNUM_MAX: ::std::os::raw::c_uint = 4294967295;
pub const MEMORY_OBJECT_COPY_NONE: ::std::os::raw::c_uint = 0;
pub const MEMORY_OBJECT_COPY_CALL: ::std::os::raw::c_uint = 1;
pub const MEMORY_OBJECT_COPY_DELAY: ::std::os::raw::c_uint = 2;
pub const MEMORY_OBJECT_COPY_TEMPORARY: ::std::os::raw::c_uint = 3;
pub const MEMORY_OBJECT_COPY_SYMMETRIC: ::std::os::raw::c_uint = 4;
pub const MEMORY_OBJECT_COPY_INVALID: ::std::os::raw::c_uint = 5;
pub const MEMORY_OBJECT_RETURN_NONE: ::std::os::raw::c_uint = 0;
pub const MEMORY_OBJECT_RETURN_DIRTY: ::std::os::raw::c_uint = 1;
pub const MEMORY_OBJECT_RETURN_ALL: ::std::os::raw::c_uint = 2;
pub const MEMORY_OBJECT_RETURN_ANYTHING: ::std::os::raw::c_uint = 3;
pub const MEMORY_OBJECT_DATA_FLUSH: ::std::os::raw::c_uint = 1;
pub const MEMORY_OBJECT_DATA_NO_CHANGE: ::std::os::raw::c_uint = 2;
pub const MEMORY_OBJECT_DATA_PURGE: ::std::os::raw::c_uint = 4;
pub const MEMORY_OBJECT_COPY_SYNC: ::std::os::raw::c_uint = 8;
pub const MEMORY_OBJECT_DATA_SYNC: ::std::os::raw::c_uint = 16;
pub const MEMORY_OBJECT_IO_SYNC: ::std::os::raw::c_uint = 32;
pub const MEMORY_OBJECT_DATA_FLUSH_ALL: ::std::os::raw::c_uint = 64;
pub const MEMORY_OBJECT_INFO_MAX: ::std::os::raw::c_uint = 1024;
pub const MEMORY_OBJECT_PERFORMANCE_INFO: ::std::os::raw::c_uint = 11;
pub const MEMORY_OBJECT_ATTRIBUTE_INFO: ::std::os::raw::c_uint = 14;
pub const MEMORY_OBJECT_BEHAVIOR_INFO: ::std::os::raw::c_uint = 15;
pub const MEMORY_OBJECT_TERMINATE_IDLE: ::std::os::raw::c_uint = 1;
pub const MEMORY_OBJECT_RESPECT_CACHE: ::std::os::raw::c_uint = 2;
pub const MEMORY_OBJECT_RELEASE_NO_OP: ::std::os::raw::c_uint = 4;
pub const MAP_MEM_NOOP: ::std::os::raw::c_uint = 0;
pub const MAP_MEM_COPYBACK: ::std::os::raw::c_uint = 1;
pub const MAP_MEM_IO: ::std::os::raw::c_uint = 2;
pub const MAP_MEM_WTHRU: ::std::os::raw::c_uint = 3;
pub const MAP_MEM_WCOMB: ::std::os::raw::c_uint = 4;
pub const MAP_MEM_INNERWBACK: ::std::os::raw::c_uint = 5;
pub const MAP_MEM_POSTED: ::std::os::raw::c_uint = 6;
pub const MAP_MEM_PURGABLE_KERNEL_ONLY: ::std::os::raw::c_uint = 16384;
pub const MAP_MEM_GRAB_SECLUDED: ::std::os::raw::c_uint = 32768;
pub const MAP_MEM_ONLY: ::std::os::raw::c_uint = 65536;
pub const MAP_MEM_NAMED_CREATE: ::std::os::raw::c_uint = 131072;
pub const MAP_MEM_PURGABLE: ::std::os::raw::c_uint = 262144;
pub const MAP_MEM_NAMED_REUSE: ::std::os::raw::c_uint = 524288;
pub const MAP_MEM_USE_DATA_ADDR: ::std::os::raw::c_uint = 1048576;
pub const MAP_MEM_VM_COPY: ::std::os::raw::c_uint = 2097152;
pub const MAP_MEM_VM_SHARE: ::std::os::raw::c_uint = 4194304;
pub const MAP_MEM_4K_DATA_ADDR: ::std::os::raw::c_uint = 8388608;
pub const MAP_MEM_FLAGS_MASK: ::std::os::raw::c_uint = 16776960;
pub const MAP_MEM_FLAGS_USER: ::std::os::raw::c_uint = 16760832;
pub const EXC_TYPES_COUNT: ::std::os::raw::c_uint = 14;
pub const EXCEPTION_CODE_MAX: ::std::os::raw::c_uint = 2;
pub const EXC_I386_INVOP: ::std::os::raw::c_uint = 1;
pub const EXC_I386_DIV: ::std::os::raw::c_uint = 1;
pub const EXC_I386_INTO: ::std::os::raw::c_uint = 2;
pub const EXC_I386_NOEXT: ::std::os::raw::c_uint = 3;
pub const EXC_I386_EXTOVR: ::std::os::raw::c_uint = 4;
pub const EXC_I386_EXTERR: ::std::os::raw::c_uint = 5;
pub const EXC_I386_EMERR: ::std::os::raw::c_uint = 6;
pub const EXC_I386_BOUND: ::std::os::raw::c_uint = 7;
pub const EXC_I386_SSEEXTERR: ::std::os::raw::c_uint = 8;
pub const EXC_I386_SGL: ::std::os::raw::c_uint = 1;
pub const EXC_I386_BPT: ::std::os::raw::c_uint = 2;
pub const EXC_I386_DIVERR: ::std::os::raw::c_uint = 0;
pub const EXC_I386_SGLSTP: ::std::os::raw::c_uint = 1;
pub const EXC_I386_NMIFLT: ::std::os::raw::c_uint = 2;
pub const EXC_I386_BPTFLT: ::std::os::raw::c_uint = 3;
pub const EXC_I386_INTOFLT: ::std::os::raw::c_uint = 4;
pub const EXC_I386_BOUNDFLT: ::std::os::raw::c_uint = 5;
pub const EXC_I386_INVOPFLT: ::std::os::raw::c_uint = 6;
pub const EXC_I386_NOEXTFLT: ::std::os::raw::c_uint = 7;
pub const EXC_I386_DBLFLT: ::std::os::raw::c_uint = 8;
pub const EXC_I386_EXTOVRFLT: ::std::os::raw::c_uint = 9;
pub const EXC_I386_INVTSSFLT: ::std::os::raw::c_uint = 10;
pub const EXC_I386_SEGNPFLT: ::std::os::raw::c_uint = 11;
pub const EXC_I386_STKFLT: ::std::os::raw::c_uint = 12;
pub const EXC_I386_GPFLT: ::std::os::raw::c_uint = 13;
pub const EXC_I386_PGFLT: ::std::os::raw::c_uint = 14;
pub const EXC_I386_EXTERRFLT: ::std::os::raw::c_uint = 16;
pub const EXC_I386_ALIGNFLT: ::std::os::raw::c_uint = 17;
pub const EXC_I386_ENDPERR: ::std::os::raw::c_uint = 33;
pub const EXC_I386_ENOEXTFLT: ::std::os::raw::c_uint = 32;
pub const EXC_MASK_MACHINE: ::std::os::raw::c_uint = 0;
pub const EXC_BAD_ACCESS: ::std::os::raw::c_uint = 1;
pub const EXC_BAD_INSTRUCTION: ::std::os::raw::c_uint = 2;
pub const EXC_ARITHMETIC: ::std::os::raw::c_uint = 3;
pub const EXC_EMULATION: ::std::os::raw::c_uint = 4;
pub const EXC_SOFTWARE: ::std::os::raw::c_uint = 5;
pub const EXC_BREAKPOINT: ::std::os::raw::c_uint = 6;
pub const EXC_SYSCALL: ::std::os::raw::c_uint = 7;
pub const EXC_MACH_SYSCALL: ::std::os::raw::c_uint = 8;
pub const EXC_RPC_ALERT: ::std::os::raw::c_uint = 9;
pub const EXC_CRASH: ::std::os::raw::c_uint = 10;
pub const EXC_RESOURCE: ::std::os::raw::c_uint = 11;
pub const EXC_GUARD: ::std::os::raw::c_uint = 12;
pub const EXC_CORPSE_NOTIFY: ::std::os::raw::c_uint = 13;
pub const EXC_CORPSE_VARIANT_BIT: ::std::os::raw::c_uint = 256;
pub const EXCEPTION_DEFAULT: ::std::os::raw::c_uint = 1;
pub const EXCEPTION_STATE: ::std::os::raw::c_uint = 2;
pub const EXCEPTION_STATE_IDENTITY: ::std::os::raw::c_uint = 3;
pub const MACH_EXCEPTION_CODES: ::std::os::raw::c_uint = 2147483648;
pub const EXC_MASK_BAD_ACCESS: ::std::os::raw::c_uint = 2;
pub const EXC_MASK_BAD_INSTRUCTION: ::std::os::raw::c_uint = 4;
pub const EXC_MASK_ARITHMETIC: ::std::os::raw::c_uint = 8;
pub const EXC_MASK_EMULATION: ::std::os::raw::c_uint = 16;
pub const EXC_MASK_SOFTWARE: ::std::os::raw::c_uint = 32;
pub const EXC_MASK_BREAKPOINT: ::std::os::raw::c_uint = 64;
pub const EXC_MASK_SYSCALL: ::std::os::raw::c_uint = 128;
pub const EXC_MASK_MACH_SYSCALL: ::std::os::raw::c_uint = 256;
pub const EXC_MASK_RPC_ALERT: ::std::os::raw::c_uint = 512;
pub const EXC_MASK_CRASH: ::std::os::raw::c_uint = 1024;
pub const EXC_MASK_RESOURCE: ::std::os::raw::c_uint = 2048;
pub const EXC_MASK_GUARD: ::std::os::raw::c_uint = 4096;
pub const EXC_MASK_CORPSE_NOTIFY: ::std::os::raw::c_uint = 8192;
pub const EXC_MASK_ALL: ::std::os::raw::c_uint = 7166;
pub const FIRST_EXCEPTION: ::std::os::raw::c_uint = 1;
pub const EXC_SOFT_SIGNAL: ::std::os::raw::c_uint = 65539;
pub const EXC_MACF_MIN: ::std::os::raw::c_uint = 131072;
pub const EXC_MACF_MAX: ::std::os::raw::c_uint = 196607;
pub const FP_PREC_24B: ::std::os::raw::c_uint = 0;
pub const FP_PREC_53B: ::std::os::raw::c_uint = 2;
pub const FP_PREC_64B: ::std::os::raw::c_uint = 3;
pub const FP_RND_NEAR: ::std::os::raw::c_uint = 0;
pub const FP_RND_DOWN: ::std::os::raw::c_uint = 1;
pub const FP_RND_UP: ::std::os::raw::c_uint = 2;
pub const FP_CHOP: ::std::os::raw::c_uint = 3;
pub const FP_STATE_BYTES: ::std::os::raw::c_uint = 512;
pub const FPC_IE: ::std::os::raw::c_uint = 1;
pub const FPC_IM: ::std::os::raw::c_uint = 1;
pub const FPC_DE: ::std::os::raw::c_uint = 2;
pub const FPC_DM: ::std::os::raw::c_uint = 2;
pub const FPC_ZE: ::std::os::raw::c_uint = 4;
pub const FPC_ZM: ::std::os::raw::c_uint = 4;
pub const FPC_OE: ::std::os::raw::c_uint = 8;
pub const FPC_OM: ::std::os::raw::c_uint = 8;
pub const FPC_UE: ::std::os::raw::c_uint = 16;
pub const FPC_PE: ::std::os::raw::c_uint = 32;
pub const FPC_PC: ::std::os::raw::c_uint = 768;
pub const FPC_PC_24: ::std::os::raw::c_uint = 0;
pub const FPC_PC_53: ::std::os::raw::c_uint = 512;
pub const FPC_PC_64: ::std::os::raw::c_uint = 768;
pub const FPC_RC: ::std::os::raw::c_uint = 3072;
pub const FPC_RC_RN: ::std::os::raw::c_uint = 0;
pub const FPC_RC_RD: ::std::os::raw::c_uint = 1024;
pub const FPC_RC_RU: ::std::os::raw::c_uint = 2048;
pub const FPC_RC_CHOP: ::std::os::raw::c_uint = 3072;
pub const FPC_IC: ::std::os::raw::c_uint = 4096;
pub const FPC_IC_PROJ: ::std::os::raw::c_uint = 0;
pub const FPC_IC_AFF: ::std::os::raw::c_uint = 4096;
pub const FPS_IE: ::std::os::raw::c_uint = 1;
pub const FPS_DE: ::std::os::raw::c_uint = 2;
pub const FPS_ZE: ::std::os::raw::c_uint = 4;
pub const FPS_OE: ::std::os::raw::c_uint = 8;
pub const FPS_UE: ::std::os::raw::c_uint = 16;
pub const FPS_PE: ::std::os::raw::c_uint = 32;
pub const FPS_SF: ::std::os::raw::c_uint = 64;
pub const FPS_ES: ::std::os::raw::c_uint = 128;
pub const FPS_C0: ::std::os::raw::c_uint = 256;
pub const FPS_C1: ::std::os::raw::c_uint = 512;
pub const FPS_C2: ::std::os::raw::c_uint = 1024;
pub const FPS_TOS: ::std::os::raw::c_uint = 14336;
pub const FPS_TOS_SHIFT: ::std::os::raw::c_uint = 11;
pub const FPS_C3: ::std::os::raw::c_uint = 16384;
pub const FPS_BUSY: ::std::os::raw::c_uint = 32768;
pub const FP_NO: ::std::os::raw::c_uint = 0;
pub const FP_SOFT: ::std::os::raw::c_uint = 1;
pub const FP_287: ::std::os::raw::c_uint = 2;
pub const FP_387: ::std::os::raw::c_uint = 3;
pub const FP_FXSR: ::std::os::raw::c_uint = 4;
pub const I386_THREAD_STATE_MAX: ::std::os::raw::c_uint = 614;
pub const THREAD_STATE_MAX: ::std::os::raw::c_uint = 614;
pub const EFL_CF: ::std::os::raw::c_uint = 1;
pub const EFL_PF: ::std::os::raw::c_uint = 4;
pub const EFL_AF: ::std::os::raw::c_uint = 16;
pub const EFL_ZF: ::std::os::raw::c_uint = 64;
pub const EFL_SF: ::std::os::raw::c_uint = 128;
pub const EFL_TF: ::std::os::raw::c_uint = 256;
pub const EFL_IF: ::std::os::raw::c_uint = 512;
pub const EFL_DF: ::std::os::raw::c_uint = 1024;
pub const EFL_OF: ::std::os::raw::c_uint = 2048;
pub const EFL_IOPL: ::std::os::raw::c_uint = 12288;
pub const EFL_IOPL_KERNEL: ::std::os::raw::c_uint = 0;
pub const EFL_IOPL_USER: ::std::os::raw::c_uint = 12288;
pub const EFL_NT: ::std::os::raw::c_uint = 16384;
pub const EFL_RF: ::std::os::raw::c_uint = 65536;
pub const EFL_VM: ::std::os::raw::c_uint = 131072;
pub const EFL_AC: ::std::os::raw::c_uint = 262144;
pub const EFL_VIF: ::std::os::raw::c_uint = 524288;
pub const EFL_VIP: ::std::os::raw::c_uint = 1048576;
pub const EFL_ID: ::std::os::raw::c_uint = 2097152;
pub const EFL_CLR: ::std::os::raw::c_uint = 4294475816;
pub const EFL_SET: ::std::os::raw::c_uint = 2;
pub const EFL_USER_SET: ::std::os::raw::c_uint = 512;
pub const EFL_USER_CLEAR: ::std::os::raw::c_uint = 94208;
pub const i386_THREAD_STATE: ::std::os::raw::c_uint = 1;
pub const i386_FLOAT_STATE: ::std::os::raw::c_uint = 2;
pub const i386_EXCEPTION_STATE: ::std::os::raw::c_uint = 3;
pub const x86_THREAD_STATE32: ::std::os::raw::c_uint = 1;
pub const x86_FLOAT_STATE32: ::std::os::raw::c_uint = 2;
pub const x86_EXCEPTION_STATE32: ::std::os::raw::c_uint = 3;
pub const x86_THREAD_STATE64: ::std::os::raw::c_uint = 4;
pub const x86_FLOAT_STATE64: ::std::os::raw::c_uint = 5;
pub const x86_EXCEPTION_STATE64: ::std::os::raw::c_uint = 6;
pub const x86_THREAD_STATE: ::std::os::raw::c_uint = 7;
pub const x86_FLOAT_STATE: ::std::os::raw::c_uint = 8;
pub const x86_EXCEPTION_STATE: ::std::os::raw::c_uint = 9;
pub const x86_DEBUG_STATE32: ::std::os::raw::c_uint = 10;
pub const x86_DEBUG_STATE64: ::std::os::raw::c_uint = 11;
pub const x86_DEBUG_STATE: ::std::os::raw::c_uint = 12;
pub const THREAD_STATE_NONE: ::std::os::raw::c_uint = 13;
pub const x86_AVX_STATE32: ::std::os::raw::c_uint = 16;
pub const x86_AVX_STATE64: ::std::os::raw::c_uint = 17;
pub const x86_AVX_STATE: ::std::os::raw::c_uint = 18;
pub const x86_AVX512_STATE32: ::std::os::raw::c_uint = 19;
pub const x86_AVX512_STATE64: ::std::os::raw::c_uint = 20;
pub const x86_AVX512_STATE: ::std::os::raw::c_uint = 21;
pub const THREAD_MACHINE_STATE_MAX: ::std::os::raw::c_uint = 614;
pub const USER_CODE_SELECTOR: ::std::os::raw::c_uint = 23;
pub const USER_DATA_SELECTOR: ::std::os::raw::c_uint = 31;
pub const KERN_CODE_SELECTOR: ::std::os::raw::c_uint = 8;
pub const KERN_DATA_SELECTOR: ::std::os::raw::c_uint = 16;
pub const MACHINE_THREAD_STATE: ::std::os::raw::c_uint = 7;
pub const THREAD_STATE_FLAVOR_LIST: ::std::os::raw::c_uint = 0;
pub const THREAD_STATE_FLAVOR_LIST_NEW: ::std::os::raw::c_uint = 128;
pub const THREAD_STATE_FLAVOR_LIST_10_9: ::std::os::raw::c_uint = 129;
pub const THREAD_STATE_FLAVOR_LIST_10_13: ::std::os::raw::c_uint = 130;
pub const MACH_VOUCHER_ATTR_MAX_RAW_RECIPE_ARRAY_SIZE: ::std::os::raw::c_uint = 5120;
pub const MACH_VOUCHER_TRAP_STACK_LIMIT: ::std::os::raw::c_uint = 256;
pub const MACH_VOUCHER_IMPORTANCE_ATTR_ADD_EXTERNAL: ::std::os::raw::c_uint = 1;
pub const MACH_VOUCHER_IMPORTANCE_ATTR_DROP_EXTERNAL: ::std::os::raw::c_uint = 2;
pub const MACH_ACTIVITY_ID_COUNT_MAX: ::std::os::raw::c_uint = 16;
pub const PROCESSOR_INFO_MAX: ::std::os::raw::c_uint = 1024;
pub const PROCESSOR_SET_INFO_MAX: ::std::os::raw::c_uint = 1024;
pub const PROCESSOR_BASIC_INFO: ::std::os::raw::c_uint = 1;
pub const PROCESSOR_CPU_LOAD_INFO: ::std::os::raw::c_uint = 2;
pub const PROCESSOR_PM_REGS_INFO: ::std::os::raw::c_uint = 268435457;
pub const PROCESSOR_TEMPERATURE: ::std::os::raw::c_uint = 268435458;
pub const LOAD_SCALE: ::std::os::raw::c_uint = 1000;
pub const PROCESSOR_SET_BASIC_INFO: ::std::os::raw::c_uint = 5;
pub const PROCESSOR_SET_LOAD_INFO: ::std::os::raw::c_uint = 4;
pub const POLICY_NULL: ::std::os::raw::c_uint = 0;
pub const POLICY_TIMESHARE: ::std::os::raw::c_uint = 1;
pub const POLICY_RR: ::std::os::raw::c_uint = 2;
pub const POLICY_FIFO: ::std::os::raw::c_uint = 4;
pub const POLICYCLASS_FIXEDPRI: ::std::os::raw::c_uint = 6;
pub const TASK_INFO_MAX: ::std::os::raw::c_uint = 1024;
pub const TASK_BASIC_INFO_32: ::std::os::raw::c_uint = 4;
pub const TASK_BASIC2_INFO_32: ::std::os::raw::c_uint = 6;
pub const TASK_BASIC_INFO_64: ::std::os::raw::c_uint = 5;
pub const TASK_BASIC_INFO: ::std::os::raw::c_uint = 5;
pub const TASK_EVENTS_INFO: ::std::os::raw::c_uint = 2;
pub const TASK_THREAD_TIMES_INFO: ::std::os::raw::c_uint = 3;
pub const TASK_ABSOLUTETIME_INFO: ::std::os::raw::c_uint = 1;
pub const TASK_KERNELMEMORY_INFO: ::std::os::raw::c_uint = 7;
pub const TASK_SECURITY_TOKEN: ::std::os::raw::c_uint = 13;
pub const TASK_AUDIT_TOKEN: ::std::os::raw::c_uint = 15;
pub const TASK_AFFINITY_TAG_INFO: ::std::os::raw::c_uint = 16;
pub const TASK_DYLD_INFO: ::std::os::raw::c_uint = 17;
pub const TASK_DYLD_ALL_IMAGE_INFO_32: ::std::os::raw::c_uint = 0;
pub const TASK_DYLD_ALL_IMAGE_INFO_64: ::std::os::raw::c_uint = 1;
pub const TASK_EXTMOD_INFO: ::std::os::raw::c_uint = 19;
pub const MACH_TASK_BASIC_INFO: ::std::os::raw::c_uint = 20;
pub const TASK_POWER_INFO: ::std::os::raw::c_uint = 21;
pub const TASK_VM_INFO: ::std::os::raw::c_uint = 22;
pub const TASK_VM_INFO_PURGEABLE: ::std::os::raw::c_uint = 23;
pub const TASK_TRACE_MEMORY_INFO: ::std::os::raw::c_uint = 24;
pub const TASK_WAIT_STATE_INFO: ::std::os::raw::c_uint = 25;
pub const TASK_POWER_INFO_V2: ::std::os::raw::c_uint = 26;
pub const TASK_VM_INFO_PURGEABLE_ACCOUNT: ::std::os::raw::c_uint = 27;
pub const TASK_FLAGS_INFO: ::std::os::raw::c_uint = 28;
pub const TF_LP64: ::std::os::raw::c_uint = 1;
pub const TASK_DEBUG_INFO_INTERNAL: ::std::os::raw::c_uint = 29;
pub const TASK_SCHED_TIMESHARE_INFO: ::std::os::raw::c_uint = 10;
pub const TASK_SCHED_RR_INFO: ::std::os::raw::c_uint = 11;
pub const TASK_SCHED_FIFO_INFO: ::std::os::raw::c_uint = 12;
pub const TASK_SCHED_INFO: ::std::os::raw::c_uint = 14;
pub const TASK_CATEGORY_POLICY: ::std::os::raw::c_uint = 1;
pub const TASK_SUPPRESSION_POLICY: ::std::os::raw::c_uint = 3;
pub const TASK_POLICY_STATE: ::std::os::raw::c_uint = 4;
pub const TASK_BASE_QOS_POLICY: ::std::os::raw::c_uint = 8;
pub const TASK_OVERRIDE_QOS_POLICY: ::std::os::raw::c_uint = 9;
pub const TASK_BASE_LATENCY_QOS_POLICY: ::std::os::raw::c_uint = 10;
pub const TASK_BASE_THROUGHPUT_QOS_POLICY: ::std::os::raw::c_uint = 11;
pub const PROC_FLAG_DARWINBG: ::std::os::raw::c_uint = 32768;
pub const PROC_FLAG_EXT_DARWINBG: ::std::os::raw::c_uint = 65536;
pub const PROC_FLAG_IOS_APPLEDAEMON: ::std::os::raw::c_uint = 131072;
pub const PROC_FLAG_IOS_IMPPROMOTION: ::std::os::raw::c_uint = 524288;
pub const PROC_FLAG_ADAPTIVE: ::std::os::raw::c_uint = 1048576;
pub const PROC_FLAG_ADAPTIVE_IMPORTANT: ::std::os::raw::c_uint = 2097152;
pub const PROC_FLAG_IMPORTANCE_DONOR: ::std::os::raw::c_uint = 4194304;
pub const PROC_FLAG_SUPPRESSED: ::std::os::raw::c_uint = 8388608;
pub const PROC_FLAG_APPLICATION: ::std::os::raw::c_uint = 16777216;
pub const PROC_FLAG_IOS_APPLICATION: ::std::os::raw::c_uint = 16777216;
pub const TASK_KERNEL_PORT: ::std::os::raw::c_uint = 1;
pub const TASK_HOST_PORT: ::std::os::raw::c_uint = 2;
pub const TASK_NAME_PORT: ::std::os::raw::c_uint = 3;
pub const TASK_BOOTSTRAP_PORT: ::std::os::raw::c_uint = 4;
pub const TASK_SEATBELT_PORT: ::std::os::raw::c_uint = 7;
pub const TASK_ACCESS_PORT: ::std::os::raw::c_uint = 9;
pub const TASK_DEBUG_CONTROL_PORT: ::std::os::raw::c_uint = 10;
pub const TASK_RESOURCE_NOTIFY_PORT: ::std::os::raw::c_uint = 11;
pub const THREAD_INFO_MAX: ::std::os::raw::c_uint = 32;
pub const THREAD_BASIC_INFO: ::std::os::raw::c_uint = 3;
pub const THREAD_IDENTIFIER_INFO: ::std::os::raw::c_uint = 4;
pub const TH_USAGE_SCALE: ::std::os::raw::c_uint = 1000;
pub const TH_STATE_RUNNING: ::std::os::raw::c_uint = 1;
pub const TH_STATE_STOPPED: ::std::os::raw::c_uint = 2;
pub const TH_STATE_WAITING: ::std::os::raw::c_uint = 3;
pub const TH_STATE_UNINTERRUPTIBLE: ::std::os::raw::c_uint = 4;
pub const TH_STATE_HALTED: ::std::os::raw::c_uint = 5;
pub const TH_FLAGS_SWAPPED: ::std::os::raw::c_uint = 1;
pub const TH_FLAGS_IDLE: ::std::os::raw::c_uint = 2;
pub const TH_FLAGS_GLOBAL_FORCED_IDLE: ::std::os::raw::c_uint = 4;
pub const THREAD_EXTENDED_INFO: ::std::os::raw::c_uint = 5;
pub const MAXTHREADNAMESIZE: ::std::os::raw::c_uint = 64;
pub const THREAD_DEBUG_INFO_INTERNAL: ::std::os::raw::c_uint = 6;
pub const IO_NUM_PRIORITIES: ::std::os::raw::c_uint = 4;
pub const THREAD_SCHED_TIMESHARE_INFO: ::std::os::raw::c_uint = 10;
pub const THREAD_SCHED_RR_INFO: ::std::os::raw::c_uint = 11;
pub const THREAD_SCHED_FIFO_INFO: ::std::os::raw::c_uint = 12;
pub const THREAD_STANDARD_POLICY: ::std::os::raw::c_uint = 1;
pub const THREAD_STANDARD_POLICY_COUNT: ::std::os::raw::c_uint = 0;
pub const THREAD_EXTENDED_POLICY: ::std::os::raw::c_uint = 1;
pub const THREAD_TIME_CONSTRAINT_POLICY: ::std::os::raw::c_uint = 2;
pub const THREAD_PRECEDENCE_POLICY: ::std::os::raw::c_uint = 3;
pub const THREAD_AFFINITY_POLICY: ::std::os::raw::c_uint = 4;
pub const THREAD_AFFINITY_TAG_NULL: ::std::os::raw::c_uint = 0;
pub const THREAD_BACKGROUND_POLICY: ::std::os::raw::c_uint = 5;
pub const THREAD_BACKGROUND_POLICY_DARWIN_BG: ::std::os::raw::c_uint = 4096;
pub const THREAD_LATENCY_QOS_POLICY: ::std::os::raw::c_uint = 7;
pub const THREAD_THROUGHPUT_QOS_POLICY: ::std::os::raw::c_uint = 8;
pub const THREAD_KERNEL_PORT: ::std::os::raw::c_uint = 1;
pub const SYSTEM_CLOCK: ::std::os::raw::c_uint = 0;
pub const CALENDAR_CLOCK: ::std::os::raw::c_uint = 1;
pub const REALTIME_CLOCK: ::std::os::raw::c_uint = 0;
pub const CLOCK_GET_TIME_RES: ::std::os::raw::c_uint = 1;
pub const CLOCK_ALARM_CURRES: ::std::os::raw::c_uint = 3;
pub const CLOCK_ALARM_MINRES: ::std::os::raw::c_uint = 4;
pub const CLOCK_ALARM_MAXRES: ::std::os::raw::c_uint = 5;
pub const NSEC_PER_USEC: ::std::os::raw::c_uint = 1000;
pub const USEC_PER_SEC: ::std::os::raw::c_uint = 1000000;
pub const NSEC_PER_SEC: ::std::os::raw::c_uint = 1000000000;
pub const NSEC_PER_MSEC: ::std::os::raw::c_uint = 1000000;
pub const ALRMTYPE: ::std::os::raw::c_uint = 255;
pub const TIME_ABSOLUTE: ::std::os::raw::c_uint = 0;
pub const TIME_RELATIVE: ::std::os::raw::c_uint = 1;
pub const MATTR_CACHE: ::std::os::raw::c_uint = 1;
pub const MATTR_MIGRATE: ::std::os::raw::c_uint = 2;
pub const MATTR_REPLICATE: ::std::os::raw::c_uint = 4;
pub const MATTR_VAL_OFF: ::std::os::raw::c_uint = 0;
pub const MATTR_VAL_ON: ::std::os::raw::c_uint = 1;
pub const MATTR_VAL_GET: ::std::os::raw::c_uint = 2;
pub const MATTR_VAL_CACHE_FLUSH: ::std::os::raw::c_uint = 6;
pub const MATTR_VAL_DCACHE_FLUSH: ::std::os::raw::c_uint = 7;
pub const MATTR_VAL_ICACHE_FLUSH: ::std::os::raw::c_uint = 8;
pub const MATTR_VAL_CACHE_SYNC: ::std::os::raw::c_uint = 9;
pub const MATTR_VAL_GET_INFO: ::std::os::raw::c_uint = 10;
pub const VM_PURGABLE_NO_AGING_SHIFT: ::std::os::raw::c_uint = 16;
pub const VM_PURGABLE_NO_AGING_MASK: ::std::os::raw::c_uint = 65536;
pub const VM_PURGABLE_NO_AGING: ::std::os::raw::c_uint = 65536;
pub const VM_PURGABLE_DEBUG_SHIFT: ::std::os::raw::c_uint = 12;
pub const VM_PURGABLE_DEBUG_MASK: ::std::os::raw::c_uint = 12288;
pub const VM_PURGABLE_DEBUG_EMPTY: ::std::os::raw::c_uint = 4096;
pub const VM_PURGABLE_DEBUG_FAULT: ::std::os::raw::c_uint = 8192;
pub const VM_VOLATILE_GROUP_SHIFT: ::std::os::raw::c_uint = 8;
pub const VM_VOLATILE_GROUP_MASK: ::std::os::raw::c_uint = 1792;
pub const VM_VOLATILE_GROUP_0: ::std::os::raw::c_uint = 0;
pub const VM_VOLATILE_GROUP_1: ::std::os::raw::c_uint = 256;
pub const VM_VOLATILE_GROUP_2: ::std::os::raw::c_uint = 512;
pub const VM_VOLATILE_GROUP_3: ::std::os::raw::c_uint = 768;
pub const VM_VOLATILE_GROUP_4: ::std::os::raw::c_uint = 1024;
pub const VM_VOLATILE_GROUP_5: ::std::os::raw::c_uint = 1280;
pub const VM_VOLATILE_GROUP_6: ::std::os::raw::c_uint = 1536;
pub const VM_VOLATILE_GROUP_7: ::std::os::raw::c_uint = 1792;
pub const VM_PURGABLE_BEHAVIOR_SHIFT: ::std::os::raw::c_uint = 6;
pub const VM_PURGABLE_BEHAVIOR_MASK: ::std::os::raw::c_uint = 64;
pub const VM_PURGABLE_BEHAVIOR_FIFO: ::std::os::raw::c_uint = 0;
pub const VM_PURGABLE_BEHAVIOR_LIFO: ::std::os::raw::c_uint = 64;
pub const VM_PURGABLE_ORDERING_SHIFT: ::std::os::raw::c_uint = 5;
pub const VM_PURGABLE_ORDERING_MASK: ::std::os::raw::c_uint = 32;
pub const VM_PURGABLE_ORDERING_OBSOLETE: ::std::os::raw::c_uint = 32;
pub const VM_PURGABLE_ORDERING_NORMAL: ::std::os::raw::c_uint = 0;
pub const VM_VOLATILE_ORDER_SHIFT: ::std::os::raw::c_uint = 4;
pub const VM_VOLATILE_ORDER_MASK: ::std::os::raw::c_uint = 16;
pub const VM_VOLATILE_MAKE_FIRST_IN_GROUP: ::std::os::raw::c_uint = 16;
pub const VM_VOLATILE_MAKE_LAST_IN_GROUP: ::std::os::raw::c_uint = 0;
pub const VM_PURGABLE_STATE_MIN: ::std::os::raw::c_uint = 0;
pub const VM_PURGABLE_STATE_MAX: ::std::os::raw::c_uint = 3;
pub const VM_PURGABLE_STATE_MASK: ::std::os::raw::c_uint = 3;
pub const VM_PURGABLE_NONVOLATILE: ::std::os::raw::c_uint = 0;
pub const VM_PURGABLE_VOLATILE: ::std::os::raw::c_uint = 1;
pub const VM_PURGABLE_EMPTY: ::std::os::raw::c_uint = 2;
pub const VM_PURGABLE_DENY: ::std::os::raw::c_uint = 3;
pub const VM_PURGABLE_ALL_MASKS: ::std::os::raw::c_uint = 79731;
pub const VM_REGION_INFO_MAX: ::std::os::raw::c_uint = 1024;
pub const VM_REGION_BASIC_INFO_64: ::std::os::raw::c_uint = 9;
pub const VM_REGION_BASIC_INFO: ::std::os::raw::c_uint = 10;
pub const SM_COW: ::std::os::raw::c_uint = 1;
pub const SM_PRIVATE: ::std::os::raw::c_uint = 2;
pub const SM_EMPTY: ::std::os::raw::c_uint = 3;
pub const SM_SHARED: ::std::os::raw::c_uint = 4;
pub const SM_TRUESHARED: ::std::os::raw::c_uint = 5;
pub const SM_PRIVATE_ALIASED: ::std::os::raw::c_uint = 6;
pub const SM_SHARED_ALIASED: ::std::os::raw::c_uint = 7;
pub const SM_LARGE_PAGE: ::std::os::raw::c_uint = 8;
pub const VM_REGION_EXTENDED_INFO: ::std::os::raw::c_uint = 13;
pub const VM_REGION_TOP_INFO: ::std::os::raw::c_uint = 12;
pub const VM_MAP_ENTRY_MAX: ::std::os::raw::c_uint = 256;
pub const VM_PAGE_INFO_BASIC: ::std::os::raw::c_uint = 1;
pub const KMOD_MAX_NAME: ::std::os::raw::c_uint = 64;
pub const KMOD_RETURN_SUCCESS: ::std::os::raw::c_uint = 0;
pub const KMOD_RETURN_FAILURE: ::std::os::raw::c_uint = 5;
pub const KMOD_INFO_VERSION: ::std::os::raw::c_uint = 1;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __mbstate8: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>(),
               128usize,
               concat!("Size of: ", stringify!(__mbstate_t)));
    assert_eq!(::std::mem::align_of::<__mbstate_t>(),
               8usize,
               concat!("Alignment of ", stringify!(__mbstate_t)));
    assert_eq!(unsafe { &(*(0 as *const __mbstate_t)).__mbstate8 as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__mbstate_t),
                       "::",
                       stringify!(__mbstate8)));
    assert_eq!(unsafe { &(*(0 as *const __mbstate_t))._mbstateL as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__mbstate_t),
                       "::",
                       stringify!(_mbstateL)));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>(),
               24usize,
               concat!("Size of: ", stringify!(__darwin_pthread_handler_rec)));
    assert_eq!(::std::mem::align_of::<__darwin_pthread_handler_rec>(),
               8usize,
               concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_pthread_handler_rec)).__routine as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_pthread_handler_rec),
                       "::",
                       stringify!(__routine)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_pthread_handler_rec)).__arg as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_pthread_handler_rec),
                       "::",
                       stringify!(__arg)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_pthread_handler_rec)).__next as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_pthread_handler_rec),
                       "::",
                       stringify!(__next)));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>(),
               64usize,
               concat!("Size of: ", stringify!(_opaque_pthread_attr_t)));
    assert_eq!(::std::mem::align_of::<_opaque_pthread_attr_t>(),
               8usize,
               concat!("Alignment of ", stringify!(_opaque_pthread_attr_t)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_attr_t)).__sig as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_attr_t),
                       "::",
                       stringify!(__sig)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_attr_t)).__opaque as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_attr_t),
                       "::",
                       stringify!(__opaque)));
}
#[repr(C)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>(),
               48usize,
               concat!("Size of: ", stringify!(_opaque_pthread_cond_t)));
    assert_eq!(::std::mem::align_of::<_opaque_pthread_cond_t>(),
               8usize,
               concat!("Alignment of ", stringify!(_opaque_pthread_cond_t)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_cond_t)).__sig as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_cond_t),
                       "::",
                       stringify!(__sig)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_cond_t)).__opaque as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_cond_t),
                       "::",
                       stringify!(__opaque)));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>(),
               16usize,
               concat!("Size of: ", stringify!(_opaque_pthread_condattr_t)));
    assert_eq!(::std::mem::align_of::<_opaque_pthread_condattr_t>(),
               8usize,
               concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_condattr_t)).__sig as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_condattr_t),
                       "::",
                       stringify!(__sig)));
    assert_eq!(unsafe {
                   &(*(0 as *const _opaque_pthread_condattr_t)).__opaque as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_condattr_t),
                       "::",
                       stringify!(__opaque)));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>(),
               64usize,
               concat!("Size of: ", stringify!(_opaque_pthread_mutex_t)));
    assert_eq!(::std::mem::align_of::<_opaque_pthread_mutex_t>(),
               8usize,
               concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_mutex_t)).__sig as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_mutex_t),
                       "::",
                       stringify!(__sig)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_mutex_t)).__opaque as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_mutex_t),
                       "::",
                       stringify!(__opaque)));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
               16usize,
               concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t)));
    assert_eq!(::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
               8usize,
               concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_mutexattr_t)).__sig as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_mutexattr_t),
                       "::",
                       stringify!(__sig)));
    assert_eq!(unsafe {
                   &(*(0 as *const _opaque_pthread_mutexattr_t)).__opaque as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_mutexattr_t),
                       "::",
                       stringify!(__opaque)));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>(),
               16usize,
               concat!("Size of: ", stringify!(_opaque_pthread_once_t)));
    assert_eq!(::std::mem::align_of::<_opaque_pthread_once_t>(),
               8usize,
               concat!("Alignment of ", stringify!(_opaque_pthread_once_t)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_once_t)).__sig as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_once_t),
                       "::",
                       stringify!(__sig)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_once_t)).__opaque as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_once_t),
                       "::",
                       stringify!(__opaque)));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
               200usize,
               concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t)));
    assert_eq!(::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
               8usize,
               concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_rwlock_t)).__sig as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_rwlock_t),
                       "::",
                       stringify!(__sig)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_rwlock_t)).__opaque as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_rwlock_t),
                       "::",
                       stringify!(__opaque)));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
               24usize,
               concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t)));
    assert_eq!(::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
               8usize,
               concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const _opaque_pthread_rwlockattr_t)).__sig as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_rwlockattr_t),
                       "::",
                       stringify!(__sig)));
    assert_eq!(unsafe {
                   &(*(0 as *const _opaque_pthread_rwlockattr_t)).__opaque as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_rwlockattr_t),
                       "::",
                       stringify!(__opaque)));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>(),
               8192usize,
               concat!("Size of: ", stringify!(_opaque_pthread_t)));
    assert_eq!(::std::mem::align_of::<_opaque_pthread_t>(),
               8usize,
               concat!("Alignment of ", stringify!(_opaque_pthread_t)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_t)).__sig as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_t),
                       "::",
                       stringify!(__sig)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_t)).__cleanup_stack as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_t),
                       "::",
                       stringify!(__cleanup_stack)));
    assert_eq!(unsafe { &(*(0 as *const _opaque_pthread_t)).__opaque as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(_opaque_pthread_t),
                       "::",
                       stringify!(__opaque)));
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type boolean_t = ::std::os::raw::c_uint;
pub type natural_t = __darwin_natural_t;
pub type integer_t = ::std::os::raw::c_int;
pub type vm_offset_t = usize;
pub type vm_size_t = usize;
pub type mach_vm_address_t = u64;
pub type mach_vm_offset_t = u64;
pub type mach_vm_size_t = u64;
pub type vm_map_offset_t = u64;
pub type vm_map_address_t = u64;
pub type vm_map_size_t = u64;
pub type mach_port_context_t = mach_vm_address_t;
pub type mach_port_name_t = natural_t;
pub type mach_port_name_array_t = *mut mach_port_name_t;
pub type mach_port_t = __darwin_mach_port_t;
pub type mach_port_array_t = *mut mach_port_t;
pub type mach_port_right_t = natural_t;
pub type mach_port_type_t = natural_t;
pub type mach_port_type_array_t = *mut mach_port_type_t;
pub type mach_port_urefs_t = natural_t;
pub type mach_port_delta_t = integer_t;
pub type mach_port_seqno_t = natural_t;
pub type mach_port_mscount_t = natural_t;
pub type mach_port_msgcount_t = natural_t;
pub type mach_port_rights_t = natural_t;
pub type mach_port_srights_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_port_status {
    pub mps_pset: mach_port_rights_t,
    pub mps_seqno: mach_port_seqno_t,
    pub mps_mscount: mach_port_mscount_t,
    pub mps_qlimit: mach_port_msgcount_t,
    pub mps_msgcount: mach_port_msgcount_t,
    pub mps_sorights: mach_port_rights_t,
    pub mps_srights: boolean_t,
    pub mps_pdrequest: boolean_t,
    pub mps_nsrequest: boolean_t,
    pub mps_flags: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_status() {
    assert_eq!(::std::mem::size_of::<mach_port_status>(),
               40usize,
               concat!("Size of: ", stringify!(mach_port_status)));
    assert_eq!(::std::mem::align_of::<mach_port_status>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_port_status)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_status)).mps_pset as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_status),
                       "::",
                       stringify!(mps_pset)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_status)).mps_seqno as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_status),
                       "::",
                       stringify!(mps_seqno)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_status)).mps_mscount as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_status),
                       "::",
                       stringify!(mps_mscount)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_status)).mps_qlimit as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_status),
                       "::",
                       stringify!(mps_qlimit)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_status)).mps_msgcount as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_status),
                       "::",
                       stringify!(mps_msgcount)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_status)).mps_sorights as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_status),
                       "::",
                       stringify!(mps_sorights)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_status)).mps_srights as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_status),
                       "::",
                       stringify!(mps_srights)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_status)).mps_pdrequest as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_status),
                       "::",
                       stringify!(mps_pdrequest)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_status)).mps_nsrequest as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_status),
                       "::",
                       stringify!(mps_nsrequest)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_status)).mps_flags as *const _ as usize },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_status),
                       "::",
                       stringify!(mps_flags)));
}
impl Clone for mach_port_status {
    fn clone(&self) -> Self {
        *self
    }
}
pub type mach_port_status_t = mach_port_status;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_port_limits {
    pub mpl_qlimit: mach_port_msgcount_t,
}
#[test]
fn bindgen_test_layout_mach_port_limits() {
    assert_eq!(::std::mem::size_of::<mach_port_limits>(),
               4usize,
               concat!("Size of: ", stringify!(mach_port_limits)));
    assert_eq!(::std::mem::align_of::<mach_port_limits>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_port_limits)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_limits)).mpl_qlimit as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_limits),
                       "::",
                       stringify!(mpl_qlimit)));
}
impl Clone for mach_port_limits {
    fn clone(&self) -> Self {
        *self
    }
}
pub type mach_port_limits_t = mach_port_limits;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_port_info_ext {
    pub mpie_status: mach_port_status_t,
    pub mpie_boost_cnt: mach_port_msgcount_t,
    pub reserved: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_mach_port_info_ext() {
    assert_eq!(::std::mem::size_of::<mach_port_info_ext>(),
               68usize,
               concat!("Size of: ", stringify!(mach_port_info_ext)));
    assert_eq!(::std::mem::align_of::<mach_port_info_ext>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_port_info_ext)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_info_ext)).mpie_status as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_info_ext),
                       "::",
                       stringify!(mpie_status)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_info_ext)).mpie_boost_cnt as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_info_ext),
                       "::",
                       stringify!(mpie_boost_cnt)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_info_ext)).reserved as *const _ as usize },
               44usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_info_ext),
                       "::",
                       stringify!(reserved)));
}
impl Clone for mach_port_info_ext {
    fn clone(&self) -> Self {
        *self
    }
}
pub type mach_port_info_ext_t = mach_port_info_ext;
pub type mach_port_info_t = *mut integer_t;
pub type mach_port_flavor_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_port_qos {
    pub _bitfield_1: u32,
    pub len: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_qos() {
    assert_eq!(::std::mem::size_of::<mach_port_qos>(),
               8usize,
               concat!("Size of: ", stringify!(mach_port_qos)));
    assert_eq!(::std::mem::align_of::<mach_port_qos>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_port_qos)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_qos)).len as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_qos),
                       "::",
                       stringify!(len)));
}
impl Clone for mach_port_qos {
    fn clone(&self) -> Self {
        *self
    }
}
impl mach_port_qos {
    #[inline]
    pub fn name(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_name(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn prealloc(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_prealloc(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn pad1(&self) -> boolean_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967292u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: boolean_t) {
        let mask = 4294967292u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(name: ::std::os::raw::c_uint,
                          prealloc: ::std::os::raw::c_uint,
                          pad1: boolean_t)
                          -> u32 {
        ({
             ({
                  ({
                       0
                   } | ((name as u32 as u32) << 0usize) & (1u64 as u32))
              } | ((prealloc as u32 as u32) << 1usize) & (2u64 as u32))
         } | ((pad1 as u32 as u32) << 2usize) & (4294967292u64 as u32))
    }
}
pub type mach_port_qos_t = mach_port_qos;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_port_options {
    pub flags: u32,
    pub mpl: mach_port_limits_t,
    pub reserved: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_mach_port_options() {
    assert_eq!(::std::mem::size_of::<mach_port_options>(),
               24usize,
               concat!("Size of: ", stringify!(mach_port_options)));
    assert_eq!(::std::mem::align_of::<mach_port_options>(),
               8usize,
               concat!("Alignment of ", stringify!(mach_port_options)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_options)).flags as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_options),
                       "::",
                       stringify!(flags)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_options)).mpl as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_options),
                       "::",
                       stringify!(mpl)));
    assert_eq!(unsafe { &(*(0 as *const mach_port_options)).reserved as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(mach_port_options),
                       "::",
                       stringify!(reserved)));
}
impl Clone for mach_port_options {
    fn clone(&self) -> Self {
        *self
    }
}
pub type mach_port_options_t = mach_port_options;
pub type mach_port_options_ptr_t = *mut mach_port_options_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mach_port_guard_exception_codes {
    kGUARD_EXC_DESTROY = 1,
    kGUARD_EXC_MOD_REFS = 2,
    kGUARD_EXC_SET_CONTEXT = 4,
    kGUARD_EXC_UNGUARDED = 8,
    kGUARD_EXC_INCORRECT_GUARD = 16,
}
pub type kern_return_t = ::std::os::raw::c_int;
pub type mach_msg_timeout_t = natural_t;
pub type mach_msg_bits_t = ::std::os::raw::c_uint;
pub type mach_msg_size_t = natural_t;
pub type mach_msg_id_t = integer_t;
pub type mach_msg_priority_t = ::std::os::raw::c_uint;
pub type mach_msg_type_name_t = ::std::os::raw::c_uint;
pub type mach_msg_copy_options_t = ::std::os::raw::c_uint;
pub type mach_msg_descriptor_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_type_descriptor_t {
    pub pad1: natural_t,
    pub pad2: mach_msg_size_t,
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_mach_msg_type_descriptor_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_type_descriptor_t>(),
               12usize,
               concat!("Size of: ", stringify!(mach_msg_type_descriptor_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_type_descriptor_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_type_descriptor_t)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_type_descriptor_t)).pad1 as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_type_descriptor_t),
                       "::",
                       stringify!(pad1)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_type_descriptor_t)).pad2 as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_type_descriptor_t),
                       "::",
                       stringify!(pad2)));
}
impl Clone for mach_msg_type_descriptor_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl mach_msg_type_descriptor_t {
    #[inline]
    pub fn pad3(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16777215u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_pad3(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16777215u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(pad3: ::std::os::raw::c_uint, type_: mach_msg_descriptor_type_t) -> u32 {
        ({
             ({
                  0
              } | ((pad3 as u32 as u32) << 0usize) & (16777215u64 as u32))
         } | ((type_ as u32 as u32) << 24usize) & (4278190080u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_port_descriptor_t {
    pub name: mach_port_t,
    pub pad1: mach_msg_size_t,
    pub _bitfield_1: [u16; 2usize],
}
#[test]
fn bindgen_test_layout_mach_msg_port_descriptor_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_port_descriptor_t>(),
               12usize,
               concat!("Size of: ", stringify!(mach_msg_port_descriptor_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_port_descriptor_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_port_descriptor_t)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_port_descriptor_t)).name as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_port_descriptor_t),
                       "::",
                       stringify!(name)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_port_descriptor_t)).pad1 as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_port_descriptor_t),
                       "::",
                       stringify!(pad1)));
}
impl Clone for mach_msg_port_descriptor_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl mach_msg_port_descriptor_t {
    #[inline]
    pub fn pad2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65535u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_pad2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65535u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16711680u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        let mask = 16711680u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(pad2: ::std::os::raw::c_uint,
                          disposition: mach_msg_type_name_t,
                          type_: mach_msg_descriptor_type_t)
                          -> u32 {
        ({
             ({
                  ({
                       0
                   } | ((pad2 as u32 as u32) << 0usize) & (65535u64 as u32))
              } | ((disposition as u32 as u32) << 16usize) & (16711680u64 as u32))
         } | ((type_ as u32 as u32) << 24usize) & (4278190080u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_ool_descriptor32_t {
    pub address: u32,
    pub size: mach_msg_size_t,
    pub _bitfield_1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor32_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_ool_descriptor32_t>(),
               12usize,
               concat!("Size of: ", stringify!(mach_msg_ool_descriptor32_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_ool_descriptor32_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_ool_descriptor32_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_ool_descriptor32_t)).address as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_ool_descriptor32_t),
                       "::",
                       stringify!(address)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_ool_descriptor32_t)).size as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_ool_descriptor32_t),
                       "::",
                       stringify!(size)));
}
impl Clone for mach_msg_ool_descriptor32_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl mach_msg_ool_descriptor32_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn pad1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16711680u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16711680u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(deallocate: boolean_t,
                          copy: mach_msg_copy_options_t,
                          pad1: ::std::os::raw::c_uint,
                          type_: mach_msg_descriptor_type_t)
                          -> u32 {
        ({
             ({
                  ({
                       ({
                            0
                        } |
                        ((deallocate as u32 as u32) << 0usize) & (255u64 as u32))
                   } | ((copy as u32 as u32) << 8usize) & (65280u64 as u32))
              } | ((pad1 as u32 as u32) << 16usize) & (16711680u64 as u32))
         } | ((type_ as u32 as u32) << 24usize) & (4278190080u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_ool_descriptor64_t {
    pub address: u64,
    pub _bitfield_1: [u8; 4usize],
    pub size: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor64_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_ool_descriptor64_t>(),
               16usize,
               concat!("Size of: ", stringify!(mach_msg_ool_descriptor64_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_ool_descriptor64_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_ool_descriptor64_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_ool_descriptor64_t)).address as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_ool_descriptor64_t),
                       "::",
                       stringify!(address)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_ool_descriptor64_t)).size as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_ool_descriptor64_t),
                       "::",
                       stringify!(size)));
}
impl Clone for mach_msg_ool_descriptor64_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl mach_msg_ool_descriptor64_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn pad1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16711680u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16711680u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(deallocate: boolean_t,
                          copy: mach_msg_copy_options_t,
                          pad1: ::std::os::raw::c_uint,
                          type_: mach_msg_descriptor_type_t)
                          -> u32 {
        ({
             ({
                  ({
                       ({
                            0
                        } |
                        ((deallocate as u32 as u32) << 0usize) & (255u64 as u32))
                   } | ((copy as u32 as u32) << 8usize) & (65280u64 as u32))
              } | ((pad1 as u32 as u32) << 16usize) & (16711680u64 as u32))
         } | ((type_ as u32 as u32) << 24usize) & (4278190080u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_ool_descriptor_t {
    pub address: *mut ::std::os::raw::c_void,
    pub _bitfield_1: [u8; 4usize],
    pub size: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_ool_descriptor_t>(),
               16usize,
               concat!("Size of: ", stringify!(mach_msg_ool_descriptor_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_ool_descriptor_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_ool_descriptor_t)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_ool_descriptor_t)).address as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_ool_descriptor_t),
                       "::",
                       stringify!(address)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_ool_descriptor_t)).size as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_ool_descriptor_t),
                       "::",
                       stringify!(size)));
}
impl Clone for mach_msg_ool_descriptor_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl mach_msg_ool_descriptor_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn pad1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16711680u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16711680u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(deallocate: boolean_t,
                          copy: mach_msg_copy_options_t,
                          pad1: ::std::os::raw::c_uint,
                          type_: mach_msg_descriptor_type_t)
                          -> u32 {
        ({
             ({
                  ({
                       ({
                            0
                        } |
                        ((deallocate as u32 as u32) << 0usize) & (255u64 as u32))
                   } | ((copy as u32 as u32) << 8usize) & (65280u64 as u32))
              } | ((pad1 as u32 as u32) << 16usize) & (16711680u64 as u32))
         } | ((type_ as u32 as u32) << 24usize) & (4278190080u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_ool_ports_descriptor32_t {
    pub address: u32,
    pub count: mach_msg_size_t,
    pub _bitfield_1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor32_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_ool_ports_descriptor32_t>(),
               12usize,
               concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor32_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_ool_ports_descriptor32_t>(),
               4usize,
               concat!("Alignment of ",
                       stringify!(mach_msg_ool_ports_descriptor32_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_ool_ports_descriptor32_t)).address as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_ool_ports_descriptor32_t),
                       "::",
                       stringify!(address)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_ool_ports_descriptor32_t)).count as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_ool_ports_descriptor32_t),
                       "::",
                       stringify!(count)));
}
impl Clone for mach_msg_ool_ports_descriptor32_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl mach_msg_ool_ports_descriptor32_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16711680u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        let mask = 16711680u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(deallocate: boolean_t,
                          copy: mach_msg_copy_options_t,
                          disposition: mach_msg_type_name_t,
                          type_: mach_msg_descriptor_type_t)
                          -> u32 {
        ({
             ({
                  ({
                       ({
                            0
                        } |
                        ((deallocate as u32 as u32) << 0usize) & (255u64 as u32))
                   } | ((copy as u32 as u32) << 8usize) & (65280u64 as u32))
              } | ((disposition as u32 as u32) << 16usize) & (16711680u64 as u32))
         } | ((type_ as u32 as u32) << 24usize) & (4278190080u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_ool_ports_descriptor64_t {
    pub address: u64,
    pub _bitfield_1: [u8; 4usize],
    pub count: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor64_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_ool_ports_descriptor64_t>(),
               16usize,
               concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor64_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_ool_ports_descriptor64_t>(),
               4usize,
               concat!("Alignment of ",
                       stringify!(mach_msg_ool_ports_descriptor64_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_ool_ports_descriptor64_t)).address as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_ool_ports_descriptor64_t),
                       "::",
                       stringify!(address)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_ool_ports_descriptor64_t)).count as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_ool_ports_descriptor64_t),
                       "::",
                       stringify!(count)));
}
impl Clone for mach_msg_ool_ports_descriptor64_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl mach_msg_ool_ports_descriptor64_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16711680u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        let mask = 16711680u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(deallocate: boolean_t,
                          copy: mach_msg_copy_options_t,
                          disposition: mach_msg_type_name_t,
                          type_: mach_msg_descriptor_type_t)
                          -> u32 {
        ({
             ({
                  ({
                       ({
                            0
                        } |
                        ((deallocate as u32 as u32) << 0usize) & (255u64 as u32))
                   } | ((copy as u32 as u32) << 8usize) & (65280u64 as u32))
              } | ((disposition as u32 as u32) << 16usize) & (16711680u64 as u32))
         } | ((type_ as u32 as u32) << 24usize) & (4278190080u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_ool_ports_descriptor_t {
    pub address: *mut ::std::os::raw::c_void,
    pub _bitfield_1: [u8; 4usize],
    pub count: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_ool_ports_descriptor_t>(),
               16usize,
               concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_ool_ports_descriptor_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_ool_ports_descriptor_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_ool_ports_descriptor_t)).address as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_ool_ports_descriptor_t),
                       "::",
                       stringify!(address)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_ool_ports_descriptor_t)).count as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_ool_ports_descriptor_t),
                       "::",
                       stringify!(count)));
}
impl Clone for mach_msg_ool_ports_descriptor_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl mach_msg_ool_ports_descriptor_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16711680u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        let mask = 16711680u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u32 as *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(deallocate: boolean_t,
                          copy: mach_msg_copy_options_t,
                          disposition: mach_msg_type_name_t,
                          type_: mach_msg_descriptor_type_t)
                          -> u32 {
        ({
             ({
                  ({
                       ({
                            0
                        } |
                        ((deallocate as u32 as u32) << 0usize) & (255u64 as u32))
                   } | ((copy as u32 as u32) << 8usize) & (65280u64 as u32))
              } | ((disposition as u32 as u32) << 16usize) & (16711680u64 as u32))
         } | ((type_ as u32 as u32) << 24usize) & (4278190080u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_descriptor_t {
    pub port: __BindgenUnionField<mach_msg_port_descriptor_t>,
    pub out_of_line: __BindgenUnionField<mach_msg_ool_descriptor_t>,
    pub ool_ports: __BindgenUnionField<mach_msg_ool_ports_descriptor_t>,
    pub type_: __BindgenUnionField<mach_msg_type_descriptor_t>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_mach_msg_descriptor_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_descriptor_t>(),
               16usize,
               concat!("Size of: ", stringify!(mach_msg_descriptor_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_descriptor_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_descriptor_t)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_descriptor_t)).port as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_descriptor_t),
                       "::",
                       stringify!(port)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_descriptor_t)).out_of_line as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_descriptor_t),
                       "::",
                       stringify!(out_of_line)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_descriptor_t)).ool_ports as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_descriptor_t),
                       "::",
                       stringify!(ool_ports)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_descriptor_t)).type_ as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_descriptor_t),
                       "::",
                       stringify!(type_)));
}
impl Clone for mach_msg_descriptor_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_body_t {
    pub msgh_descriptor_count: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_body_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_body_t>(),
               4usize,
               concat!("Size of: ", stringify!(mach_msg_body_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_body_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_body_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_body_t)).msgh_descriptor_count as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_body_t),
                       "::",
                       stringify!(msgh_descriptor_count)));
}
impl Clone for mach_msg_body_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_header_t {
    pub msgh_bits: mach_msg_bits_t,
    pub msgh_size: mach_msg_size_t,
    pub msgh_remote_port: mach_port_t,
    pub msgh_local_port: mach_port_t,
    pub msgh_voucher_port: mach_port_name_t,
    pub msgh_id: mach_msg_id_t,
}
#[test]
fn bindgen_test_layout_mach_msg_header_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_header_t>(),
               24usize,
               concat!("Size of: ", stringify!(mach_msg_header_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_header_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_header_t)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_header_t)).msgh_bits as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_header_t),
                       "::",
                       stringify!(msgh_bits)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_header_t)).msgh_size as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_header_t),
                       "::",
                       stringify!(msgh_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_header_t)).msgh_remote_port as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_header_t),
                       "::",
                       stringify!(msgh_remote_port)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_header_t)).msgh_local_port as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_header_t),
                       "::",
                       stringify!(msgh_local_port)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_header_t)).msgh_voucher_port as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_header_t),
                       "::",
                       stringify!(msgh_voucher_port)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_header_t)).msgh_id as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_header_t),
                       "::",
                       stringify!(msgh_id)));
}
impl Clone for mach_msg_header_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_base_t {
    pub header: mach_msg_header_t,
    pub body: mach_msg_body_t,
}
#[test]
fn bindgen_test_layout_mach_msg_base_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_base_t>(),
               28usize,
               concat!("Size of: ", stringify!(mach_msg_base_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_base_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_base_t)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_base_t)).header as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_base_t),
                       "::",
                       stringify!(header)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_base_t)).body as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_base_t),
                       "::",
                       stringify!(body)));
}
impl Clone for mach_msg_base_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type mach_msg_trailer_type_t = ::std::os::raw::c_uint;
pub type mach_msg_trailer_size_t = ::std::os::raw::c_uint;
pub type mach_msg_trailer_info_t = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_trailer_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_trailer_t>(),
               8usize,
               concat!("Size of: ", stringify!(mach_msg_trailer_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_trailer_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_trailer_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_trailer_t)).msgh_trailer_type as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_trailer_t),
                       "::",
                       stringify!(msgh_trailer_type)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_trailer_t)).msgh_trailer_size as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_trailer_t),
                       "::",
                       stringify!(msgh_trailer_size)));
}
impl Clone for mach_msg_trailer_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_seqno_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
}
#[test]
fn bindgen_test_layout_mach_msg_seqno_trailer_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_seqno_trailer_t>(),
               12usize,
               concat!("Size of: ", stringify!(mach_msg_seqno_trailer_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_seqno_trailer_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_seqno_trailer_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_seqno_trailer_t)).msgh_trailer_type as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_seqno_trailer_t),
                       "::",
                       stringify!(msgh_trailer_type)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_seqno_trailer_t)).msgh_trailer_size as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_seqno_trailer_t),
                       "::",
                       stringify!(msgh_trailer_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_seqno_trailer_t)).msgh_seqno as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_seqno_trailer_t),
                       "::",
                       stringify!(msgh_seqno)));
}
impl Clone for mach_msg_seqno_trailer_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct security_token_t {
    pub val: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_security_token_t() {
    assert_eq!(::std::mem::size_of::<security_token_t>(),
               8usize,
               concat!("Size of: ", stringify!(security_token_t)));
    assert_eq!(::std::mem::align_of::<security_token_t>(),
               4usize,
               concat!("Alignment of ", stringify!(security_token_t)));
    assert_eq!(unsafe { &(*(0 as *const security_token_t)).val as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(security_token_t),
                       "::",
                       stringify!(val)));
}
impl Clone for security_token_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_security_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
}
#[test]
fn bindgen_test_layout_mach_msg_security_trailer_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_security_trailer_t>(),
               20usize,
               concat!("Size of: ", stringify!(mach_msg_security_trailer_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_security_trailer_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_security_trailer_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_security_trailer_t)).msgh_trailer_type as *const _ as
                   usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_security_trailer_t),
                       "::",
                       stringify!(msgh_trailer_type)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_security_trailer_t)).msgh_trailer_size as *const _ as
                   usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_security_trailer_t),
                       "::",
                       stringify!(msgh_trailer_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_security_trailer_t)).msgh_seqno as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_security_trailer_t),
                       "::",
                       stringify!(msgh_seqno)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_security_trailer_t)).msgh_sender as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_security_trailer_t),
                       "::",
                       stringify!(msgh_sender)));
}
impl Clone for mach_msg_security_trailer_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct audit_token_t {
    pub val: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout_audit_token_t() {
    assert_eq!(::std::mem::size_of::<audit_token_t>(),
               32usize,
               concat!("Size of: ", stringify!(audit_token_t)));
    assert_eq!(::std::mem::align_of::<audit_token_t>(),
               4usize,
               concat!("Alignment of ", stringify!(audit_token_t)));
    assert_eq!(unsafe { &(*(0 as *const audit_token_t)).val as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(audit_token_t),
                       "::",
                       stringify!(val)));
}
impl Clone for audit_token_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_audit_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
    pub msgh_audit: audit_token_t,
}
#[test]
fn bindgen_test_layout_mach_msg_audit_trailer_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_audit_trailer_t>(),
               52usize,
               concat!("Size of: ", stringify!(mach_msg_audit_trailer_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_audit_trailer_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_audit_trailer_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_audit_trailer_t)).msgh_trailer_type as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_audit_trailer_t),
                       "::",
                       stringify!(msgh_trailer_type)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_audit_trailer_t)).msgh_trailer_size as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_audit_trailer_t),
                       "::",
                       stringify!(msgh_trailer_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_audit_trailer_t)).msgh_seqno as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_audit_trailer_t),
                       "::",
                       stringify!(msgh_seqno)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_audit_trailer_t)).msgh_sender as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_audit_trailer_t),
                       "::",
                       stringify!(msgh_sender)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_audit_trailer_t)).msgh_audit as *const _ as usize
               },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_audit_trailer_t),
                       "::",
                       stringify!(msgh_audit)));
}
impl Clone for mach_msg_audit_trailer_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_context_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
    pub msgh_audit: audit_token_t,
    pub msgh_context: mach_port_context_t,
}
#[test]
fn bindgen_test_layout_mach_msg_context_trailer_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_context_trailer_t>(),
               60usize,
               concat!("Size of: ", stringify!(mach_msg_context_trailer_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_context_trailer_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_context_trailer_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_context_trailer_t)).msgh_trailer_type as *const _ as
                   usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_context_trailer_t),
                       "::",
                       stringify!(msgh_trailer_type)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_context_trailer_t)).msgh_trailer_size as *const _ as
                   usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_context_trailer_t),
                       "::",
                       stringify!(msgh_trailer_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_context_trailer_t)).msgh_seqno as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_context_trailer_t),
                       "::",
                       stringify!(msgh_seqno)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_context_trailer_t)).msgh_sender as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_context_trailer_t),
                       "::",
                       stringify!(msgh_sender)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_context_trailer_t)).msgh_audit as *const _ as usize
               },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_context_trailer_t),
                       "::",
                       stringify!(msgh_audit)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_context_trailer_t)).msgh_context as *const _ as usize
               },
               52usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_context_trailer_t),
                       "::",
                       stringify!(msgh_context)));
}
impl Clone for mach_msg_context_trailer_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct msg_labels_t {
    pub sender: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_msg_labels_t() {
    assert_eq!(::std::mem::size_of::<msg_labels_t>(),
               4usize,
               concat!("Size of: ", stringify!(msg_labels_t)));
    assert_eq!(::std::mem::align_of::<msg_labels_t>(),
               4usize,
               concat!("Alignment of ", stringify!(msg_labels_t)));
    assert_eq!(unsafe { &(*(0 as *const msg_labels_t)).sender as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(msg_labels_t),
                       "::",
                       stringify!(sender)));
}
impl Clone for msg_labels_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_mac_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
    pub msgh_audit: audit_token_t,
    pub msgh_context: mach_port_context_t,
    pub msgh_ad: ::std::os::raw::c_int,
    pub msgh_labels: msg_labels_t,
}
#[test]
fn bindgen_test_layout_mach_msg_mac_trailer_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_mac_trailer_t>(),
               68usize,
               concat!("Size of: ", stringify!(mach_msg_mac_trailer_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_mac_trailer_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_mac_trailer_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_mac_trailer_t)).msgh_trailer_type as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_mac_trailer_t),
                       "::",
                       stringify!(msgh_trailer_type)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_mac_trailer_t)).msgh_trailer_size as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_mac_trailer_t),
                       "::",
                       stringify!(msgh_trailer_size)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_mac_trailer_t)).msgh_seqno as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_mac_trailer_t),
                       "::",
                       stringify!(msgh_seqno)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_mac_trailer_t)).msgh_sender as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_mac_trailer_t),
                       "::",
                       stringify!(msgh_sender)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_mac_trailer_t)).msgh_audit as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_mac_trailer_t),
                       "::",
                       stringify!(msgh_audit)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_mac_trailer_t)).msgh_context as *const _ as usize
               },
               52usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_mac_trailer_t),
                       "::",
                       stringify!(msgh_context)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_mac_trailer_t)).msgh_ad as *const _ as usize },
               60usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_mac_trailer_t),
                       "::",
                       stringify!(msgh_ad)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_msg_mac_trailer_t)).msgh_labels as *const _ as usize
               },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_mac_trailer_t),
                       "::",
                       stringify!(msgh_labels)));
}
impl Clone for mach_msg_mac_trailer_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type mach_msg_max_trailer_t = mach_msg_mac_trailer_t;
pub type mach_msg_format_0_trailer_t = mach_msg_security_trailer_t;
extern "C" {
    #[link_name = "KERNEL_SECURITY_TOKEN"]
    pub static mut KERNEL_SECURITY_TOKEN: security_token_t;
}
extern "C" {
    #[link_name = "KERNEL_AUDIT_TOKEN"]
    pub static mut KERNEL_AUDIT_TOKEN: audit_token_t;
}
pub type mach_msg_options_t = integer_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_empty_send_t {
    pub header: mach_msg_header_t,
}
#[test]
fn bindgen_test_layout_mach_msg_empty_send_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_empty_send_t>(),
               24usize,
               concat!("Size of: ", stringify!(mach_msg_empty_send_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_empty_send_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_empty_send_t)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_empty_send_t)).header as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_empty_send_t),
                       "::",
                       stringify!(header)));
}
impl Clone for mach_msg_empty_send_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_empty_rcv_t {
    pub header: mach_msg_header_t,
    pub trailer: mach_msg_trailer_t,
}
#[test]
fn bindgen_test_layout_mach_msg_empty_rcv_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_empty_rcv_t>(),
               32usize,
               concat!("Size of: ", stringify!(mach_msg_empty_rcv_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_empty_rcv_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_empty_rcv_t)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_empty_rcv_t)).header as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_empty_rcv_t),
                       "::",
                       stringify!(header)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_empty_rcv_t)).trailer as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_empty_rcv_t),
                       "::",
                       stringify!(trailer)));
}
impl Clone for mach_msg_empty_rcv_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_msg_empty_t {
    pub send: __BindgenUnionField<mach_msg_empty_send_t>,
    pub rcv: __BindgenUnionField<mach_msg_empty_rcv_t>,
    pub bindgen_union_field: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_mach_msg_empty_t() {
    assert_eq!(::std::mem::size_of::<mach_msg_empty_t>(),
               32usize,
               concat!("Size of: ", stringify!(mach_msg_empty_t)));
    assert_eq!(::std::mem::align_of::<mach_msg_empty_t>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_msg_empty_t)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_empty_t)).send as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_empty_t),
                       "::",
                       stringify!(send)));
    assert_eq!(unsafe { &(*(0 as *const mach_msg_empty_t)).rcv as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_msg_empty_t),
                       "::",
                       stringify!(rcv)));
}
impl Clone for mach_msg_empty_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type mach_msg_type_size_t = natural_t;
pub type mach_msg_type_number_t = natural_t;
pub type mach_msg_option_t = integer_t;
pub type mach_msg_return_t = kern_return_t;
extern "C" {
    pub fn mach_msg_overwrite(msg: *mut mach_msg_header_t,
                              option: mach_msg_option_t,
                              send_size: mach_msg_size_t,
                              rcv_size: mach_msg_size_t,
                              rcv_name: mach_port_name_t,
                              timeout: mach_msg_timeout_t,
                              notify: mach_port_name_t,
                              rcv_msg: *mut mach_msg_header_t,
                              rcv_limit: mach_msg_size_t)
                              -> mach_msg_return_t;
}
extern "C" {
    pub fn mach_msg(msg: *mut mach_msg_header_t,
                    option: mach_msg_option_t,
                    send_size: mach_msg_size_t,
                    rcv_size: mach_msg_size_t,
                    rcv_name: mach_port_name_t,
                    timeout: mach_msg_timeout_t,
                    notify: mach_port_name_t)
                    -> mach_msg_return_t;
}
extern "C" {
    pub fn mach_voucher_deallocate(voucher: mach_port_name_t) -> kern_return_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_statistics {
    pub free_count: natural_t,
    pub active_count: natural_t,
    pub inactive_count: natural_t,
    pub wire_count: natural_t,
    pub zero_fill_count: natural_t,
    pub reactivations: natural_t,
    pub pageins: natural_t,
    pub pageouts: natural_t,
    pub faults: natural_t,
    pub cow_faults: natural_t,
    pub lookups: natural_t,
    pub hits: natural_t,
    pub purgeable_count: natural_t,
    pub purges: natural_t,
    pub speculative_count: natural_t,
}
#[test]
fn bindgen_test_layout_vm_statistics() {
    assert_eq!(::std::mem::size_of::<vm_statistics>(),
               60usize,
               concat!("Size of: ", stringify!(vm_statistics)));
    assert_eq!(::std::mem::align_of::<vm_statistics>(),
               4usize,
               concat!("Alignment of ", stringify!(vm_statistics)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).free_count as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(free_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).active_count as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(active_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).inactive_count as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(inactive_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).wire_count as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(wire_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).zero_fill_count as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(zero_fill_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).reactivations as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(reactivations)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).pageins as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(pageins)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).pageouts as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(pageouts)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).faults as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(faults)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).cow_faults as *const _ as usize },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(cow_faults)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).lookups as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(lookups)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).hits as *const _ as usize },
               44usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(hits)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).purgeable_count as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(purgeable_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).purges as *const _ as usize },
               52usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(purges)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics)).speculative_count as *const _ as usize },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics),
                       "::",
                       stringify!(speculative_count)));
}
impl Clone for vm_statistics {
    fn clone(&self) -> Self {
        *self
    }
}
pub type vm_statistics_t = *mut vm_statistics;
pub type vm_statistics_data_t = vm_statistics;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_statistics64 {
    pub free_count: natural_t,
    pub active_count: natural_t,
    pub inactive_count: natural_t,
    pub wire_count: natural_t,
    pub zero_fill_count: u64,
    pub reactivations: u64,
    pub pageins: u64,
    pub pageouts: u64,
    pub faults: u64,
    pub cow_faults: u64,
    pub lookups: u64,
    pub hits: u64,
    pub purges: u64,
    pub purgeable_count: natural_t,
    pub speculative_count: natural_t,
    pub decompressions: u64,
    pub compressions: u64,
    pub swapins: u64,
    pub swapouts: u64,
    pub compressor_page_count: natural_t,
    pub throttled_count: natural_t,
    pub external_page_count: natural_t,
    pub internal_page_count: natural_t,
    pub total_uncompressed_pages_in_compressor: u64,
}
#[test]
fn bindgen_test_layout_vm_statistics64() {
    assert_eq!(::std::mem::size_of::<vm_statistics64>(),
               152usize,
               concat!("Size of: ", stringify!(vm_statistics64)));
    assert_eq!(::std::mem::align_of::<vm_statistics64>(),
               8usize,
               concat!("Alignment of ", stringify!(vm_statistics64)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).free_count as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(free_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).active_count as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(active_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).inactive_count as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(inactive_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).wire_count as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(wire_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).zero_fill_count as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(zero_fill_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).reactivations as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(reactivations)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).pageins as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(pageins)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).pageouts as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(pageouts)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).faults as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(faults)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).cow_faults as *const _ as usize },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(cow_faults)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).lookups as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(lookups)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).hits as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(hits)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).purges as *const _ as usize },
               80usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(purges)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).purgeable_count as *const _ as usize },
               88usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(purgeable_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).speculative_count as *const _ as usize },
               92usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(speculative_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).decompressions as *const _ as usize },
               96usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(decompressions)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).compressions as *const _ as usize },
               104usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(compressions)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).swapins as *const _ as usize },
               112usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(swapins)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).swapouts as *const _ as usize },
               120usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(swapouts)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_statistics64)).compressor_page_count as *const _ as usize
               },
               128usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(compressor_page_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_statistics64)).throttled_count as *const _ as usize },
               132usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(throttled_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_statistics64)).external_page_count as *const _ as usize
               },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(external_page_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_statistics64)).internal_page_count as *const _ as usize
               },
               140usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(internal_page_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_statistics64)).total_uncompressed_pages_in_compressor as
                   *const _ as usize
               },
               144usize,
               concat!("Alignment of field: ",
                       stringify!(vm_statistics64),
                       "::",
                       stringify!(total_uncompressed_pages_in_compressor)));
}
impl Clone for vm_statistics64 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type vm_statistics64_t = *mut vm_statistics64;
pub type vm_statistics64_data_t = vm_statistics64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_extmod_statistics {
    pub task_for_pid_count: i64,
    pub task_for_pid_caller_count: i64,
    pub thread_creation_count: i64,
    pub thread_creation_caller_count: i64,
    pub thread_set_state_count: i64,
    pub thread_set_state_caller_count: i64,
}
#[test]
fn bindgen_test_layout_vm_extmod_statistics() {
    assert_eq!(::std::mem::size_of::<vm_extmod_statistics>(),
               48usize,
               concat!("Size of: ", stringify!(vm_extmod_statistics)));
    assert_eq!(::std::mem::align_of::<vm_extmod_statistics>(),
               8usize,
               concat!("Alignment of ", stringify!(vm_extmod_statistics)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_extmod_statistics)).task_for_pid_count as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_extmod_statistics),
                       "::",
                       stringify!(task_for_pid_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_extmod_statistics)).task_for_pid_caller_count as *const _ as
                   usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(vm_extmod_statistics),
                       "::",
                       stringify!(task_for_pid_caller_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_extmod_statistics)).thread_creation_count as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(vm_extmod_statistics),
                       "::",
                       stringify!(thread_creation_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_extmod_statistics)).thread_creation_caller_count as
                   *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(vm_extmod_statistics),
                       "::",
                       stringify!(thread_creation_caller_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_extmod_statistics)).thread_set_state_count as *const _ as
                   usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(vm_extmod_statistics),
                       "::",
                       stringify!(thread_set_state_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_extmod_statistics)).thread_set_state_caller_count as
                   *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(vm_extmod_statistics),
                       "::",
                       stringify!(thread_set_state_caller_count)));
}
impl Clone for vm_extmod_statistics {
    fn clone(&self) -> Self {
        *self
    }
}
pub type vm_extmod_statistics_t = *mut vm_extmod_statistics;
pub type vm_extmod_statistics_data_t = vm_extmod_statistics;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_purgeable_stat {
    pub count: u64,
    pub size: u64,
}
#[test]
fn bindgen_test_layout_vm_purgeable_stat() {
    assert_eq!(::std::mem::size_of::<vm_purgeable_stat>(),
               16usize,
               concat!("Size of: ", stringify!(vm_purgeable_stat)));
    assert_eq!(::std::mem::align_of::<vm_purgeable_stat>(),
               8usize,
               concat!("Alignment of ", stringify!(vm_purgeable_stat)));
    assert_eq!(unsafe { &(*(0 as *const vm_purgeable_stat)).count as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_purgeable_stat),
                       "::",
                       stringify!(count)));
    assert_eq!(unsafe { &(*(0 as *const vm_purgeable_stat)).size as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(vm_purgeable_stat),
                       "::",
                       stringify!(size)));
}
impl Clone for vm_purgeable_stat {
    fn clone(&self) -> Self {
        *self
    }
}
pub type vm_purgeable_stat_t = vm_purgeable_stat;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_purgeable_info {
    pub fifo_data: [vm_purgeable_stat_t; 8usize],
    pub obsolete_data: vm_purgeable_stat_t,
    pub lifo_data: [vm_purgeable_stat_t; 8usize],
}
#[test]
fn bindgen_test_layout_vm_purgeable_info() {
    assert_eq!(::std::mem::size_of::<vm_purgeable_info>(),
               272usize,
               concat!("Size of: ", stringify!(vm_purgeable_info)));
    assert_eq!(::std::mem::align_of::<vm_purgeable_info>(),
               8usize,
               concat!("Alignment of ", stringify!(vm_purgeable_info)));
    assert_eq!(unsafe { &(*(0 as *const vm_purgeable_info)).fifo_data as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_purgeable_info),
                       "::",
                       stringify!(fifo_data)));
    assert_eq!(unsafe { &(*(0 as *const vm_purgeable_info)).obsolete_data as *const _ as usize },
               128usize,
               concat!("Alignment of field: ",
                       stringify!(vm_purgeable_info),
                       "::",
                       stringify!(obsolete_data)));
    assert_eq!(unsafe { &(*(0 as *const vm_purgeable_info)).lifo_data as *const _ as usize },
               144usize,
               concat!("Alignment of field: ",
                       stringify!(vm_purgeable_info),
                       "::",
                       stringify!(lifo_data)));
}
impl Clone for vm_purgeable_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type vm_purgeable_info_t = *mut vm_purgeable_info;
pub type cpu_type_t = integer_t;
pub type cpu_subtype_t = integer_t;
pub type cpu_threadtype_t = integer_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct time_value {
    pub seconds: integer_t,
    pub microseconds: integer_t,
}
#[test]
fn bindgen_test_layout_time_value() {
    assert_eq!(::std::mem::size_of::<time_value>(),
               8usize,
               concat!("Size of: ", stringify!(time_value)));
    assert_eq!(::std::mem::align_of::<time_value>(),
               4usize,
               concat!("Alignment of ", stringify!(time_value)));
    assert_eq!(unsafe { &(*(0 as *const time_value)).seconds as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(time_value),
                       "::",
                       stringify!(seconds)));
    assert_eq!(unsafe { &(*(0 as *const time_value)).microseconds as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(time_value),
                       "::",
                       stringify!(microseconds)));
}
impl Clone for time_value {
    fn clone(&self) -> Self {
        *self
    }
}
pub type time_value_t = time_value;
pub type host_info_t = *mut integer_t;
pub type host_info64_t = *mut integer_t;
pub type host_info_data_t = [integer_t; 1024usize];
pub type kernel_version_t = [::std::os::raw::c_char; 512usize];
pub type kernel_boot_info_t = [::std::os::raw::c_char; 4096usize];
pub type host_flavor_t = integer_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct host_can_has_debugger_info {
    pub can_has_debugger: boolean_t,
}
#[test]
fn bindgen_test_layout_host_can_has_debugger_info() {
    assert_eq!(::std::mem::size_of::<host_can_has_debugger_info>(),
               4usize,
               concat!("Size of: ", stringify!(host_can_has_debugger_info)));
    assert_eq!(::std::mem::align_of::<host_can_has_debugger_info>(),
               4usize,
               concat!("Alignment of ", stringify!(host_can_has_debugger_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const host_can_has_debugger_info)).can_has_debugger as *const _ as
                   usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(host_can_has_debugger_info),
                       "::",
                       stringify!(can_has_debugger)));
}
impl Clone for host_can_has_debugger_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type host_can_has_debugger_info_data_t = host_can_has_debugger_info;
pub type host_can_has_debugger_info_t = *mut host_can_has_debugger_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct host_basic_info {
    pub max_cpus: integer_t,
    pub avail_cpus: integer_t,
    pub memory_size: natural_t,
    pub cpu_type: cpu_type_t,
    pub cpu_subtype: cpu_subtype_t,
    pub cpu_threadtype: cpu_threadtype_t,
    pub physical_cpu: integer_t,
    pub physical_cpu_max: integer_t,
    pub logical_cpu: integer_t,
    pub logical_cpu_max: integer_t,
    pub max_mem: u64,
}
#[test]
fn bindgen_test_layout_host_basic_info() {
    assert_eq!(::std::mem::size_of::<host_basic_info>(),
               48usize,
               concat!("Size of: ", stringify!(host_basic_info)));
    assert_eq!(::std::mem::align_of::<host_basic_info>(),
               4usize,
               concat!("Alignment of ", stringify!(host_basic_info)));
    assert_eq!(unsafe { &(*(0 as *const host_basic_info)).max_cpus as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(host_basic_info),
                       "::",
                       stringify!(max_cpus)));
    assert_eq!(unsafe { &(*(0 as *const host_basic_info)).avail_cpus as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(host_basic_info),
                       "::",
                       stringify!(avail_cpus)));
    assert_eq!(unsafe { &(*(0 as *const host_basic_info)).memory_size as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(host_basic_info),
                       "::",
                       stringify!(memory_size)));
    assert_eq!(unsafe { &(*(0 as *const host_basic_info)).cpu_type as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(host_basic_info),
                       "::",
                       stringify!(cpu_type)));
    assert_eq!(unsafe { &(*(0 as *const host_basic_info)).cpu_subtype as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(host_basic_info),
                       "::",
                       stringify!(cpu_subtype)));
    assert_eq!(unsafe { &(*(0 as *const host_basic_info)).cpu_threadtype as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(host_basic_info),
                       "::",
                       stringify!(cpu_threadtype)));
    assert_eq!(unsafe { &(*(0 as *const host_basic_info)).physical_cpu as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(host_basic_info),
                       "::",
                       stringify!(physical_cpu)));
    assert_eq!(unsafe { &(*(0 as *const host_basic_info)).physical_cpu_max as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(host_basic_info),
                       "::",
                       stringify!(physical_cpu_max)));
    assert_eq!(unsafe { &(*(0 as *const host_basic_info)).logical_cpu as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(host_basic_info),
                       "::",
                       stringify!(logical_cpu)));
    assert_eq!(unsafe { &(*(0 as *const host_basic_info)).logical_cpu_max as *const _ as usize },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(host_basic_info),
                       "::",
                       stringify!(logical_cpu_max)));
    assert_eq!(unsafe { &(*(0 as *const host_basic_info)).max_mem as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(host_basic_info),
                       "::",
                       stringify!(max_mem)));
}
impl Clone for host_basic_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type host_basic_info_data_t = host_basic_info;
pub type host_basic_info_t = *mut host_basic_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct host_sched_info {
    pub min_timeout: integer_t,
    pub min_quantum: integer_t,
}
#[test]
fn bindgen_test_layout_host_sched_info() {
    assert_eq!(::std::mem::size_of::<host_sched_info>(),
               8usize,
               concat!("Size of: ", stringify!(host_sched_info)));
    assert_eq!(::std::mem::align_of::<host_sched_info>(),
               4usize,
               concat!("Alignment of ", stringify!(host_sched_info)));
    assert_eq!(unsafe { &(*(0 as *const host_sched_info)).min_timeout as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(host_sched_info),
                       "::",
                       stringify!(min_timeout)));
    assert_eq!(unsafe { &(*(0 as *const host_sched_info)).min_quantum as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(host_sched_info),
                       "::",
                       stringify!(min_quantum)));
}
impl Clone for host_sched_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type host_sched_info_data_t = host_sched_info;
pub type host_sched_info_t = *mut host_sched_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kernel_resource_sizes {
    pub task: natural_t,
    pub thread: natural_t,
    pub port: natural_t,
    pub memory_region: natural_t,
    pub memory_object: natural_t,
}
#[test]
fn bindgen_test_layout_kernel_resource_sizes() {
    assert_eq!(::std::mem::size_of::<kernel_resource_sizes>(),
               20usize,
               concat!("Size of: ", stringify!(kernel_resource_sizes)));
    assert_eq!(::std::mem::align_of::<kernel_resource_sizes>(),
               4usize,
               concat!("Alignment of ", stringify!(kernel_resource_sizes)));
    assert_eq!(unsafe { &(*(0 as *const kernel_resource_sizes)).task as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(kernel_resource_sizes),
                       "::",
                       stringify!(task)));
    assert_eq!(unsafe { &(*(0 as *const kernel_resource_sizes)).thread as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(kernel_resource_sizes),
                       "::",
                       stringify!(thread)));
    assert_eq!(unsafe { &(*(0 as *const kernel_resource_sizes)).port as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(kernel_resource_sizes),
                       "::",
                       stringify!(port)));
    assert_eq!(unsafe {
                   &(*(0 as *const kernel_resource_sizes)).memory_region as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(kernel_resource_sizes),
                       "::",
                       stringify!(memory_region)));
    assert_eq!(unsafe {
                   &(*(0 as *const kernel_resource_sizes)).memory_object as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(kernel_resource_sizes),
                       "::",
                       stringify!(memory_object)));
}
impl Clone for kernel_resource_sizes {
    fn clone(&self) -> Self {
        *self
    }
}
pub type kernel_resource_sizes_data_t = kernel_resource_sizes;
pub type kernel_resource_sizes_t = *mut kernel_resource_sizes;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct host_priority_info {
    pub kernel_priority: integer_t,
    pub system_priority: integer_t,
    pub server_priority: integer_t,
    pub user_priority: integer_t,
    pub depress_priority: integer_t,
    pub idle_priority: integer_t,
    pub minimum_priority: integer_t,
    pub maximum_priority: integer_t,
}
#[test]
fn bindgen_test_layout_host_priority_info() {
    assert_eq!(::std::mem::size_of::<host_priority_info>(),
               32usize,
               concat!("Size of: ", stringify!(host_priority_info)));
    assert_eq!(::std::mem::align_of::<host_priority_info>(),
               4usize,
               concat!("Alignment of ", stringify!(host_priority_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const host_priority_info)).kernel_priority as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(host_priority_info),
                       "::",
                       stringify!(kernel_priority)));
    assert_eq!(unsafe {
                   &(*(0 as *const host_priority_info)).system_priority as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(host_priority_info),
                       "::",
                       stringify!(system_priority)));
    assert_eq!(unsafe {
                   &(*(0 as *const host_priority_info)).server_priority as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(host_priority_info),
                       "::",
                       stringify!(server_priority)));
    assert_eq!(unsafe { &(*(0 as *const host_priority_info)).user_priority as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(host_priority_info),
                       "::",
                       stringify!(user_priority)));
    assert_eq!(unsafe {
                   &(*(0 as *const host_priority_info)).depress_priority as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(host_priority_info),
                       "::",
                       stringify!(depress_priority)));
    assert_eq!(unsafe { &(*(0 as *const host_priority_info)).idle_priority as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(host_priority_info),
                       "::",
                       stringify!(idle_priority)));
    assert_eq!(unsafe {
                   &(*(0 as *const host_priority_info)).minimum_priority as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(host_priority_info),
                       "::",
                       stringify!(minimum_priority)));
    assert_eq!(unsafe {
                   &(*(0 as *const host_priority_info)).maximum_priority as *const _ as usize
               },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(host_priority_info),
                       "::",
                       stringify!(maximum_priority)));
}
impl Clone for host_priority_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type host_priority_info_data_t = host_priority_info;
pub type host_priority_info_t = *mut host_priority_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct host_load_info {
    pub avenrun: [integer_t; 3usize],
    pub mach_factor: [integer_t; 3usize],
}
#[test]
fn bindgen_test_layout_host_load_info() {
    assert_eq!(::std::mem::size_of::<host_load_info>(),
               24usize,
               concat!("Size of: ", stringify!(host_load_info)));
    assert_eq!(::std::mem::align_of::<host_load_info>(),
               4usize,
               concat!("Alignment of ", stringify!(host_load_info)));
    assert_eq!(unsafe { &(*(0 as *const host_load_info)).avenrun as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(host_load_info),
                       "::",
                       stringify!(avenrun)));
    assert_eq!(unsafe { &(*(0 as *const host_load_info)).mach_factor as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(host_load_info),
                       "::",
                       stringify!(mach_factor)));
}
impl Clone for host_load_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type host_load_info_data_t = host_load_info;
pub type host_load_info_t = *mut host_load_info;
pub type host_purgable_info_data_t = vm_purgeable_info;
pub type host_purgable_info_t = *mut vm_purgeable_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct host_cpu_load_info {
    pub cpu_ticks: [natural_t; 4usize],
}
#[test]
fn bindgen_test_layout_host_cpu_load_info() {
    assert_eq!(::std::mem::size_of::<host_cpu_load_info>(),
               16usize,
               concat!("Size of: ", stringify!(host_cpu_load_info)));
    assert_eq!(::std::mem::align_of::<host_cpu_load_info>(),
               4usize,
               concat!("Alignment of ", stringify!(host_cpu_load_info)));
    assert_eq!(unsafe { &(*(0 as *const host_cpu_load_info)).cpu_ticks as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(host_cpu_load_info),
                       "::",
                       stringify!(cpu_ticks)));
}
impl Clone for host_cpu_load_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type host_cpu_load_info_data_t = host_cpu_load_info;
pub type host_cpu_load_info_t = *mut host_cpu_load_info;
pub type vm_prot_t = ::std::os::raw::c_int;
pub type vm_sync_t = ::std::os::raw::c_uint;
pub type pointer_t = vm_offset_t;
pub type vm_address_t = vm_offset_t;
pub type addr64_t = u64;
pub type reg64_t = u32;
pub type ppnum_t = u32;
pub type vm_map_t = mach_port_t;
pub type vm_object_offset_t = u64;
pub type vm_object_size_t = u64;
pub type upl_t = mach_port_t;
pub type vm_named_entry_t = mach_port_t;
pub type memory_object_offset_t = ::std::os::raw::c_ulonglong;
pub type memory_object_size_t = ::std::os::raw::c_ulonglong;
pub type memory_object_cluster_size_t = natural_t;
pub type memory_object_fault_info_t = *mut natural_t;
pub type vm_object_id_t = ::std::os::raw::c_ulonglong;
pub type memory_object_t = mach_port_t;
pub type memory_object_control_t = mach_port_t;
pub type memory_object_array_t = *mut memory_object_t;
pub type memory_object_name_t = mach_port_t;
pub type memory_object_default_t = mach_port_t;
pub type memory_object_copy_strategy_t = ::std::os::raw::c_int;
pub type memory_object_return_t = ::std::os::raw::c_int;
pub type memory_object_info_t = *mut ::std::os::raw::c_int;
pub type memory_object_flavor_t = ::std::os::raw::c_int;
pub type memory_object_info_data_t = [::std::os::raw::c_int; 1024usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct memory_object_perf_info {
    pub cluster_size: memory_object_cluster_size_t,
    pub may_cache: boolean_t,
}
#[test]
fn bindgen_test_layout_memory_object_perf_info() {
    assert_eq!(::std::mem::size_of::<memory_object_perf_info>(),
               8usize,
               concat!("Size of: ", stringify!(memory_object_perf_info)));
    assert_eq!(::std::mem::align_of::<memory_object_perf_info>(),
               4usize,
               concat!("Alignment of ", stringify!(memory_object_perf_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const memory_object_perf_info)).cluster_size as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(memory_object_perf_info),
                       "::",
                       stringify!(cluster_size)));
    assert_eq!(unsafe { &(*(0 as *const memory_object_perf_info)).may_cache as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(memory_object_perf_info),
                       "::",
                       stringify!(may_cache)));
}
impl Clone for memory_object_perf_info {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct memory_object_attr_info {
    pub copy_strategy: memory_object_copy_strategy_t,
    pub cluster_size: memory_object_cluster_size_t,
    pub may_cache_object: boolean_t,
    pub temporary: boolean_t,
}
#[test]
fn bindgen_test_layout_memory_object_attr_info() {
    assert_eq!(::std::mem::size_of::<memory_object_attr_info>(),
               16usize,
               concat!("Size of: ", stringify!(memory_object_attr_info)));
    assert_eq!(::std::mem::align_of::<memory_object_attr_info>(),
               4usize,
               concat!("Alignment of ", stringify!(memory_object_attr_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const memory_object_attr_info)).copy_strategy as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(memory_object_attr_info),
                       "::",
                       stringify!(copy_strategy)));
    assert_eq!(unsafe {
                   &(*(0 as *const memory_object_attr_info)).cluster_size as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(memory_object_attr_info),
                       "::",
                       stringify!(cluster_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const memory_object_attr_info)).may_cache_object as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(memory_object_attr_info),
                       "::",
                       stringify!(may_cache_object)));
    assert_eq!(unsafe { &(*(0 as *const memory_object_attr_info)).temporary as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(memory_object_attr_info),
                       "::",
                       stringify!(temporary)));
}
impl Clone for memory_object_attr_info {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct memory_object_behave_info {
    pub copy_strategy: memory_object_copy_strategy_t,
    pub temporary: boolean_t,
    pub invalidate: boolean_t,
    pub silent_overwrite: boolean_t,
    pub advisory_pageout: boolean_t,
}
#[test]
fn bindgen_test_layout_memory_object_behave_info() {
    assert_eq!(::std::mem::size_of::<memory_object_behave_info>(),
               20usize,
               concat!("Size of: ", stringify!(memory_object_behave_info)));
    assert_eq!(::std::mem::align_of::<memory_object_behave_info>(),
               4usize,
               concat!("Alignment of ", stringify!(memory_object_behave_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const memory_object_behave_info)).copy_strategy as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(memory_object_behave_info),
                       "::",
                       stringify!(copy_strategy)));
    assert_eq!(unsafe {
                   &(*(0 as *const memory_object_behave_info)).temporary as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(memory_object_behave_info),
                       "::",
                       stringify!(temporary)));
    assert_eq!(unsafe {
                   &(*(0 as *const memory_object_behave_info)).invalidate as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(memory_object_behave_info),
                       "::",
                       stringify!(invalidate)));
    assert_eq!(unsafe {
                   &(*(0 as *const memory_object_behave_info)).silent_overwrite as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(memory_object_behave_info),
                       "::",
                       stringify!(silent_overwrite)));
    assert_eq!(unsafe {
                   &(*(0 as *const memory_object_behave_info)).advisory_pageout as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(memory_object_behave_info),
                       "::",
                       stringify!(advisory_pageout)));
}
impl Clone for memory_object_behave_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type memory_object_behave_info_t = *mut memory_object_behave_info;
pub type memory_object_behave_info_data_t = memory_object_behave_info;
pub type memory_object_perf_info_t = *mut memory_object_perf_info;
pub type memory_object_perf_info_data_t = memory_object_perf_info;
pub type memory_object_attr_info_t = *mut memory_object_attr_info;
pub type memory_object_attr_info_data_t = memory_object_attr_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_thread_state>(),
               64usize,
               concat!("Size of: ", stringify!(__darwin_i386_thread_state)));
    assert_eq!(::std::mem::align_of::<__darwin_i386_thread_state>(),
               4usize,
               concat!("Alignment of ", stringify!(__darwin_i386_thread_state)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__eax as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__eax)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__ebx as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__ebx)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__ecx as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__ecx)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__edx as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__edx)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__edi as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__edi)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__esi as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__esi)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__ebp as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__ebp)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__esp as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__esp)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__ss as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__ss)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_thread_state)).__eflags as *const _ as usize
               },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__eflags)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__eip as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__eip)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__cs as *const _ as usize },
               44usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__cs)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__ds as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__ds)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__es as *const _ as usize },
               52usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__es)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__fs as *const _ as usize },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__fs)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_thread_state)).__gs as *const _ as usize },
               60usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_thread_state),
                       "::",
                       stringify!(__gs)));
}
impl Clone for __darwin_i386_thread_state {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_fp_control {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(::std::mem::size_of::<__darwin_fp_control>(),
               2usize,
               concat!("Size of: ", stringify!(__darwin_fp_control)));
    assert_eq!(::std::mem::align_of::<__darwin_fp_control>(),
               2usize,
               concat!("Alignment of ", stringify!(__darwin_fp_control)));
}
impl Clone for __darwin_fp_control {
    fn clone(&self) -> Self {
        *self
    }
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 2u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 4u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 8u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 16u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 32u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 768u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 768u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 3072u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 3072u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__invalid: ::std::os::raw::c_ushort,
                          __denorm: ::std::os::raw::c_ushort,
                          __zdiv: ::std::os::raw::c_ushort,
                          __ovrfl: ::std::os::raw::c_ushort,
                          __undfl: ::std::os::raw::c_ushort,
                          __precis: ::std::os::raw::c_ushort,
                          __pc: ::std::os::raw::c_ushort,
                          __rc: ::std::os::raw::c_ushort)
                          -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                0
                                            } |
                                            ((__invalid as u16 as u16) << 0usize) & (1u64 as u16))
                                       } |
                                       ((__denorm as u16 as u16) << 1usize) & (2u64 as u16))
                                  } |
                                  ((__zdiv as u16 as u16) << 2usize) & (4u64 as u16))
                             } |
                             ((__ovrfl as u16 as u16) << 3usize) & (8u64 as u16))
                        } |
                        ((__undfl as u16 as u16) << 4usize) & (16u64 as u16))
                   } | ((__precis as u16 as u16) << 5usize) & (32u64 as u16))
              } | ((__pc as u16 as u16) << 8usize) & (768u64 as u16))
         } | ((__rc as u16 as u16) << 10usize) & (3072u64 as u16))
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_fp_status {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(::std::mem::size_of::<__darwin_fp_status>(),
               2usize,
               concat!("Size of: ", stringify!(__darwin_fp_status)));
    assert_eq!(::std::mem::align_of::<__darwin_fp_status>(),
               2usize,
               concat!("Alignment of ", stringify!(__darwin_fp_status)));
}
impl Clone for __darwin_fp_status {
    fn clone(&self) -> Self {
        *self
    }
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 2u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 4u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 8u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 16u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 32u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 64u64 as u16;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 64u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 128u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 128u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 256u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 256u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 512u64 as u16;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 512u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1024u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 1024u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 14336u64 as u16;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 14336u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16384u64 as u16;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 16384u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32768u64 as u16;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 32768u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as *const u8,
                                            &mut unit_field_val as *mut u16 as *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as *const u8,
                                            &mut self._bitfield_1 as *mut _ as *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__invalid: ::std::os::raw::c_ushort,
                          __denorm: ::std::os::raw::c_ushort,
                          __zdiv: ::std::os::raw::c_ushort,
                          __ovrfl: ::std::os::raw::c_ushort,
                          __undfl: ::std::os::raw::c_ushort,
                          __precis: ::std::os::raw::c_ushort,
                          __stkflt: ::std::os::raw::c_ushort,
                          __errsumm: ::std::os::raw::c_ushort,
                          __c0: ::std::os::raw::c_ushort,
                          __c1: ::std::os::raw::c_ushort,
                          __c2: ::std::os::raw::c_ushort,
                          __tos: ::std::os::raw::c_ushort,
                          __c3: ::std::os::raw::c_ushort,
                          __busy: ::std::os::raw::c_ushort)
                          -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({
                                                               ({
                                                                    ({
                                                                         ({
                                                                              0
                                                                          } |
                                                                          ((__invalid as u16 as
                                                                            u16) <<
                                                                           0usize) &
                                                                          (1u64 as u16))
                                                                     } |
                                                                     ((__denorm as u16 as u16) <<
                                                                      1usize) &
                                                                     (2u64 as u16))
                                                                } |
                                                                ((__zdiv as u16 as u16) << 2usize) &
                                                                (4u64 as u16))
                                                           } |
                                                           ((__ovrfl as u16 as u16) << 3usize) &
                                                           (8u64 as u16))
                                                      } |
                                                      ((__undfl as u16 as u16) << 4usize) &
                                                      (16u64 as u16))
                                                 } |
                                                 ((__precis as u16 as u16) << 5usize) &
                                                 (32u64 as u16))
                                            } |
                                            ((__stkflt as u16 as u16) << 6usize) & (64u64 as u16))
                                       } |
                                       ((__errsumm as u16 as u16) << 7usize) & (128u64 as u16))
                                  } |
                                  ((__c0 as u16 as u16) << 8usize) & (256u64 as u16))
                             } |
                             ((__c1 as u16 as u16) << 9usize) & (512u64 as u16))
                        } |
                        ((__c2 as u16 as u16) << 10usize) & (1024u64 as u16))
                   } | ((__tos as u16 as u16) << 11usize) & (14336u64 as u16))
              } | ((__c3 as u16 as u16) << 14usize) & (16384u64 as u16))
         } | ((__busy as u16 as u16) << 15usize) & (32768u64 as u16))
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_mmst_reg>(),
               16usize,
               concat!("Size of: ", stringify!(__darwin_mmst_reg)));
    assert_eq!(::std::mem::align_of::<__darwin_mmst_reg>(),
               1usize,
               concat!("Alignment of ", stringify!(__darwin_mmst_reg)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_mmst_reg)).__mmst_reg as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_mmst_reg),
                       "::",
                       stringify!(__mmst_reg)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_mmst_reg)).__mmst_rsrv as *const _ as usize },
               10usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_mmst_reg),
                       "::",
                       stringify!(__mmst_rsrv)));
}
impl Clone for __darwin_mmst_reg {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_xmm_reg>(),
               16usize,
               concat!("Size of: ", stringify!(__darwin_xmm_reg)));
    assert_eq!(::std::mem::align_of::<__darwin_xmm_reg>(),
               1usize,
               concat!("Alignment of ", stringify!(__darwin_xmm_reg)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_xmm_reg)).__xmm_reg as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_xmm_reg),
                       "::",
                       stringify!(__xmm_reg)));
}
impl Clone for __darwin_xmm_reg {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_ymm_reg {
    pub __ymm_reg: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout___darwin_ymm_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_ymm_reg>(),
               32usize,
               concat!("Size of: ", stringify!(__darwin_ymm_reg)));
    assert_eq!(::std::mem::align_of::<__darwin_ymm_reg>(),
               1usize,
               concat!("Alignment of ", stringify!(__darwin_ymm_reg)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_ymm_reg)).__ymm_reg as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_ymm_reg),
                       "::",
                       stringify!(__ymm_reg)));
}
impl Clone for __darwin_ymm_reg {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct __darwin_zmm_reg {
    pub __zmm_reg: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout___darwin_zmm_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_zmm_reg>(),
               64usize,
               concat!("Size of: ", stringify!(__darwin_zmm_reg)));
    assert_eq!(::std::mem::align_of::<__darwin_zmm_reg>(),
               1usize,
               concat!("Alignment of ", stringify!(__darwin_zmm_reg)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_zmm_reg)).__zmm_reg as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_zmm_reg),
                       "::",
                       stringify!(__zmm_reg)));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_opmask_reg {
    pub __opmask_reg: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout___darwin_opmask_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_opmask_reg>(),
               8usize,
               concat!("Size of: ", stringify!(__darwin_opmask_reg)));
    assert_eq!(::std::mem::align_of::<__darwin_opmask_reg>(),
               1usize,
               concat!("Alignment of ", stringify!(__darwin_opmask_reg)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_opmask_reg)).__opmask_reg as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_opmask_reg),
                       "::",
                       stringify!(__opmask_reg)));
}
impl Clone for __darwin_opmask_reg {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_float_state>(),
               524usize,
               concat!("Size of: ", stringify!(__darwin_i386_float_state)));
    assert_eq!(::std::mem::align_of::<__darwin_i386_float_state>(),
               4usize,
               concat!("Alignment of ", stringify!(__darwin_i386_float_state)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_reserved as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_reserved)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_fcw as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_fcw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_fsw as *const _ as usize
               },
               10usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_fsw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_ftw as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_ftw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_rsrv1 as *const _ as usize
               },
               13usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_rsrv1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_fop as *const _ as usize
               },
               14usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_fop)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_ip as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_ip)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_cs as *const _ as usize
               },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_cs)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_rsrv2 as *const _ as usize
               },
               22usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_rsrv2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_dp as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_dp)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_ds as *const _ as usize
               },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_ds)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_rsrv3 as *const _ as usize
               },
               30usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_rsrv3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_mxcsr as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_mxcsr)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_mxcsrmask as *const _ as usize
               },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_mxcsrmask)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_stmm0 as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_stmm0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_stmm1 as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_stmm1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_stmm2 as *const _ as usize
               },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_stmm2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_stmm3 as *const _ as usize
               },
               88usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_stmm3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_stmm4 as *const _ as usize
               },
               104usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_stmm4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_stmm5 as *const _ as usize
               },
               120usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_stmm5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_stmm6 as *const _ as usize
               },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_stmm6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_stmm7 as *const _ as usize
               },
               152usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_stmm7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_xmm0 as *const _ as usize
               },
               168usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_xmm0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_xmm1 as *const _ as usize
               },
               184usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_xmm1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_xmm2 as *const _ as usize
               },
               200usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_xmm2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_xmm3 as *const _ as usize
               },
               216usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_xmm3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_xmm4 as *const _ as usize
               },
               232usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_xmm4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_xmm5 as *const _ as usize
               },
               248usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_xmm5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_xmm6 as *const _ as usize
               },
               264usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_xmm6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_xmm7 as *const _ as usize
               },
               280usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_xmm7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_rsrv4 as *const _ as usize
               },
               296usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_rsrv4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_float_state)).__fpu_reserved1 as *const _ as usize
               },
               520usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_float_state),
                       "::",
                       stringify!(__fpu_reserved1)));
}
#[repr(C)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_avx_state>(),
               716usize,
               concat!("Size of: ", stringify!(__darwin_i386_avx_state)));
    assert_eq!(::std::mem::align_of::<__darwin_i386_avx_state>(),
               4usize,
               concat!("Alignment of ", stringify!(__darwin_i386_avx_state)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_reserved as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_reserved)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_avx_state)).__fpu_fcw as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_fcw)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_avx_state)).__fpu_fsw as *const _ as usize },
               10usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_fsw)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_avx_state)).__fpu_ftw as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_ftw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_rsrv1 as *const _ as usize
               },
               13usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_rsrv1)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_avx_state)).__fpu_fop as *const _ as usize },
               14usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_fop)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_avx_state)).__fpu_ip as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_ip)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_avx_state)).__fpu_cs as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_cs)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_rsrv2 as *const _ as usize
               },
               22usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_rsrv2)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_avx_state)).__fpu_dp as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_dp)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_i386_avx_state)).__fpu_ds as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_ds)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_rsrv3 as *const _ as usize
               },
               30usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_rsrv3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_mxcsr as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_mxcsr)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_mxcsrmask as *const _ as usize
               },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_mxcsrmask)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_stmm0 as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_stmm0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_stmm1 as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_stmm1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_stmm2 as *const _ as usize
               },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_stmm2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_stmm3 as *const _ as usize
               },
               88usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_stmm3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_stmm4 as *const _ as usize
               },
               104usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_stmm4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_stmm5 as *const _ as usize
               },
               120usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_stmm5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_stmm6 as *const _ as usize
               },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_stmm6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_stmm7 as *const _ as usize
               },
               152usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_stmm7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_xmm0 as *const _ as usize
               },
               168usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_xmm0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_xmm1 as *const _ as usize
               },
               184usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_xmm1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_xmm2 as *const _ as usize
               },
               200usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_xmm2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_xmm3 as *const _ as usize
               },
               216usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_xmm3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_xmm4 as *const _ as usize
               },
               232usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_xmm4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_xmm5 as *const _ as usize
               },
               248usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_xmm5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_xmm6 as *const _ as usize
               },
               264usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_xmm6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_xmm7 as *const _ as usize
               },
               280usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_xmm7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_rsrv4 as *const _ as usize
               },
               296usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_rsrv4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_reserved1 as *const _ as usize
               },
               520usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_reserved1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__avx_reserved1 as *const _ as usize
               },
               524usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__avx_reserved1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_ymmh0 as *const _ as usize
               },
               588usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_ymmh0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_ymmh1 as *const _ as usize
               },
               604usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_ymmh1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_ymmh2 as *const _ as usize
               },
               620usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_ymmh2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_ymmh3 as *const _ as usize
               },
               636usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_ymmh3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_ymmh4 as *const _ as usize
               },
               652usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_ymmh4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_ymmh5 as *const _ as usize
               },
               668usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_ymmh5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_ymmh6 as *const _ as usize
               },
               684usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_ymmh6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx_state)).__fpu_ymmh7 as *const _ as usize
               },
               700usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx_state),
                       "::",
                       stringify!(__fpu_ymmh7)));
}
#[repr(C)]
pub struct __darwin_i386_avx512_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx512_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_avx512_state>(),
               1036usize,
               concat!("Size of: ", stringify!(__darwin_i386_avx512_state)));
    assert_eq!(::std::mem::align_of::<__darwin_i386_avx512_state>(),
               4usize,
               concat!("Alignment of ", stringify!(__darwin_i386_avx512_state)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_reserved as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_reserved)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_fcw as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_fcw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_fsw as *const _ as usize
               },
               10usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_fsw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_ftw as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_ftw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_rsrv1 as *const _ as usize
               },
               13usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_rsrv1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_fop as *const _ as usize
               },
               14usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_fop)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_ip as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_ip)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_cs as *const _ as usize
               },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_cs)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_rsrv2 as *const _ as usize
               },
               22usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_rsrv2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_dp as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_dp)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_ds as *const _ as usize
               },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_ds)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_rsrv3 as *const _ as usize
               },
               30usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_rsrv3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_mxcsr as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_mxcsr)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_mxcsrmask as *const _ as usize
               },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_mxcsrmask)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_stmm0 as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_stmm0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_stmm1 as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_stmm1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_stmm2 as *const _ as usize
               },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_stmm2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_stmm3 as *const _ as usize
               },
               88usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_stmm3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_stmm4 as *const _ as usize
               },
               104usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_stmm4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_stmm5 as *const _ as usize
               },
               120usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_stmm5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_stmm6 as *const _ as usize
               },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_stmm6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_stmm7 as *const _ as usize
               },
               152usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_stmm7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_xmm0 as *const _ as usize
               },
               168usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_xmm0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_xmm1 as *const _ as usize
               },
               184usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_xmm1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_xmm2 as *const _ as usize
               },
               200usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_xmm2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_xmm3 as *const _ as usize
               },
               216usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_xmm3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_xmm4 as *const _ as usize
               },
               232usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_xmm4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_xmm5 as *const _ as usize
               },
               248usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_xmm5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_xmm6 as *const _ as usize
               },
               264usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_xmm6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_xmm7 as *const _ as usize
               },
               280usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_xmm7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_rsrv4 as *const _ as usize
               },
               296usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_rsrv4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_reserved1 as *const _ as usize
               },
               520usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_reserved1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__avx_reserved1 as *const _ as usize
               },
               524usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__avx_reserved1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_ymmh0 as *const _ as usize
               },
               588usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_ymmh0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_ymmh1 as *const _ as usize
               },
               604usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_ymmh1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_ymmh2 as *const _ as usize
               },
               620usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_ymmh2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_ymmh3 as *const _ as usize
               },
               636usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_ymmh3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_ymmh4 as *const _ as usize
               },
               652usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_ymmh4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_ymmh5 as *const _ as usize
               },
               668usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_ymmh5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_ymmh6 as *const _ as usize
               },
               684usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_ymmh6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_ymmh7 as *const _ as usize
               },
               700usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_ymmh7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_k0 as *const _ as usize
               },
               716usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_k0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_k1 as *const _ as usize
               },
               724usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_k1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_k2 as *const _ as usize
               },
               732usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_k2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_k3 as *const _ as usize
               },
               740usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_k3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_k4 as *const _ as usize
               },
               748usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_k4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_k5 as *const _ as usize
               },
               756usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_k5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_k6 as *const _ as usize
               },
               764usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_k6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_k7 as *const _ as usize
               },
               772usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_k7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_zmmh0 as *const _ as usize
               },
               780usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_zmmh0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_zmmh1 as *const _ as usize
               },
               812usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_zmmh1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_zmmh2 as *const _ as usize
               },
               844usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_zmmh2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_zmmh3 as *const _ as usize
               },
               876usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_zmmh3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_zmmh4 as *const _ as usize
               },
               908usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_zmmh4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_zmmh5 as *const _ as usize
               },
               940usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_zmmh5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_zmmh6 as *const _ as usize
               },
               972usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_zmmh6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_avx512_state)).__fpu_zmmh7 as *const _ as usize
               },
               1004usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_avx512_state),
                       "::",
                       stringify!(__fpu_zmmh7)));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_exception_state>(),
               12usize,
               concat!("Size of: ", stringify!(__darwin_i386_exception_state)));
    assert_eq!(::std::mem::align_of::<__darwin_i386_exception_state>(),
               4usize,
               concat!("Alignment of ", stringify!(__darwin_i386_exception_state)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_exception_state)).__trapno as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_exception_state),
                       "::",
                       stringify!(__trapno)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_exception_state)).__cpu as *const _ as usize
               },
               2usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_exception_state),
                       "::",
                       stringify!(__cpu)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_exception_state)).__err as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_exception_state),
                       "::",
                       stringify!(__err)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_i386_exception_state)).__faultvaddr as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_i386_exception_state),
                       "::",
                       stringify!(__faultvaddr)));
}
impl Clone for __darwin_i386_exception_state {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_debug_state32>(),
               32usize,
               concat!("Size of: ", stringify!(__darwin_x86_debug_state32)));
    assert_eq!(::std::mem::align_of::<__darwin_x86_debug_state32>(),
               4usize,
               concat!("Alignment of ", stringify!(__darwin_x86_debug_state32)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state32)).__dr0 as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state32),
                       "::",
                       stringify!(__dr0)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state32)).__dr1 as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state32),
                       "::",
                       stringify!(__dr1)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state32)).__dr2 as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state32),
                       "::",
                       stringify!(__dr2)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state32)).__dr3 as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state32),
                       "::",
                       stringify!(__dr3)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state32)).__dr4 as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state32),
                       "::",
                       stringify!(__dr4)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state32)).__dr5 as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state32),
                       "::",
                       stringify!(__dr5)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state32)).__dr6 as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state32),
                       "::",
                       stringify!(__dr6)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state32)).__dr7 as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state32),
                       "::",
                       stringify!(__dr7)));
}
impl Clone for __darwin_x86_debug_state32 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_thread_state64>(),
               168usize,
               concat!("Size of: ", stringify!(__darwin_x86_thread_state64)));
    assert_eq!(::std::mem::align_of::<__darwin_x86_thread_state64>(),
               8usize,
               concat!("Alignment of ", stringify!(__darwin_x86_thread_state64)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__rax as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__rax)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__rbx as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__rbx)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__rcx as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__rcx)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__rdx as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__rdx)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__rdi as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__rdi)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__rsi as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__rsi)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__rbp as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__rbp)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__rsp as *const _ as usize },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__rsp)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__r8 as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__r8)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__r9 as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__r9)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__r10 as *const _ as usize },
               80usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__r10)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__r11 as *const _ as usize },
               88usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__r11)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__r12 as *const _ as usize },
               96usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__r12)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__r13 as *const _ as usize },
               104usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__r13)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__r14 as *const _ as usize },
               112usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__r14)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__r15 as *const _ as usize },
               120usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__r15)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__rip as *const _ as usize },
               128usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__rip)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_thread_state64)).__rflags as *const _ as usize
               },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__rflags)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__cs as *const _ as usize },
               144usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__cs)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__fs as *const _ as usize },
               152usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__fs)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_thread_state64)).__gs as *const _ as usize },
               160usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_thread_state64),
                       "::",
                       stringify!(__gs)));
}
impl Clone for __darwin_x86_thread_state64 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_float_state64>(),
               524usize,
               concat!("Size of: ", stringify!(__darwin_x86_float_state64)));
    assert_eq!(::std::mem::align_of::<__darwin_x86_float_state64>(),
               4usize,
               concat!("Alignment of ", stringify!(__darwin_x86_float_state64)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_reserved as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_reserved)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_fcw as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_fcw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_fsw as *const _ as usize
               },
               10usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_fsw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_ftw as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_ftw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_rsrv1 as *const _ as usize
               },
               13usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_rsrv1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_fop as *const _ as usize
               },
               14usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_fop)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_ip as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_ip)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_cs as *const _ as usize
               },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_cs)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_rsrv2 as *const _ as usize
               },
               22usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_rsrv2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_dp as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_dp)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_ds as *const _ as usize
               },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_ds)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_rsrv3 as *const _ as usize
               },
               30usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_rsrv3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_mxcsr as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_mxcsr)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_mxcsrmask as *const _ as usize
               },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_mxcsrmask)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_stmm0 as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_stmm0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_stmm1 as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_stmm1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_stmm2 as *const _ as usize
               },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_stmm2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_stmm3 as *const _ as usize
               },
               88usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_stmm3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_stmm4 as *const _ as usize
               },
               104usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_stmm4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_stmm5 as *const _ as usize
               },
               120usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_stmm5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_stmm6 as *const _ as usize
               },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_stmm6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_stmm7 as *const _ as usize
               },
               152usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_stmm7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm0 as *const _ as usize
               },
               168usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm1 as *const _ as usize
               },
               184usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm2 as *const _ as usize
               },
               200usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm3 as *const _ as usize
               },
               216usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm4 as *const _ as usize
               },
               232usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm5 as *const _ as usize
               },
               248usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm6 as *const _ as usize
               },
               264usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm7 as *const _ as usize
               },
               280usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm8 as *const _ as usize
               },
               296usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm8)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm9 as *const _ as usize
               },
               312usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm9)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm10 as *const _ as usize
               },
               328usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm10)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm11 as *const _ as usize
               },
               344usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm11)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm12 as *const _ as usize
               },
               360usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm12)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm13 as *const _ as usize
               },
               376usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm13)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm14 as *const _ as usize
               },
               392usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm14)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_xmm15 as *const _ as usize
               },
               408usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_xmm15)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_rsrv4 as *const _ as usize
               },
               424usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_rsrv4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_float_state64)).__fpu_reserved1 as *const _ as usize
               },
               520usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_float_state64),
                       "::",
                       stringify!(__fpu_reserved1)));
}
#[repr(C)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_avx_state64>(),
               844usize,
               concat!("Size of: ", stringify!(__darwin_x86_avx_state64)));
    assert_eq!(::std::mem::align_of::<__darwin_x86_avx_state64>(),
               4usize,
               concat!("Alignment of ", stringify!(__darwin_x86_avx_state64)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_reserved as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_reserved)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_fcw as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_fcw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_fsw as *const _ as usize
               },
               10usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_fsw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ftw as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ftw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_rsrv1 as *const _ as usize
               },
               13usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_rsrv1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_fop as *const _ as usize
               },
               14usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_fop)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ip as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ip)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_avx_state64)).__fpu_cs as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_cs)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_rsrv2 as *const _ as usize
               },
               22usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_rsrv2)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_avx_state64)).__fpu_dp as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_dp)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ds as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ds)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_rsrv3 as *const _ as usize
               },
               30usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_rsrv3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_mxcsr as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_mxcsr)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_mxcsrmask as *const _ as usize
               },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_mxcsrmask)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_stmm0 as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_stmm0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_stmm1 as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_stmm1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_stmm2 as *const _ as usize
               },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_stmm2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_stmm3 as *const _ as usize
               },
               88usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_stmm3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_stmm4 as *const _ as usize
               },
               104usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_stmm4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_stmm5 as *const _ as usize
               },
               120usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_stmm5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_stmm6 as *const _ as usize
               },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_stmm6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_stmm7 as *const _ as usize
               },
               152usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_stmm7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm0 as *const _ as usize
               },
               168usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm1 as *const _ as usize
               },
               184usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm2 as *const _ as usize
               },
               200usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm3 as *const _ as usize
               },
               216usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm4 as *const _ as usize
               },
               232usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm5 as *const _ as usize
               },
               248usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm6 as *const _ as usize
               },
               264usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm7 as *const _ as usize
               },
               280usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm8 as *const _ as usize
               },
               296usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm8)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm9 as *const _ as usize
               },
               312usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm9)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm10 as *const _ as usize
               },
               328usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm10)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm11 as *const _ as usize
               },
               344usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm11)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm12 as *const _ as usize
               },
               360usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm12)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm13 as *const _ as usize
               },
               376usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm13)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm14 as *const _ as usize
               },
               392usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm14)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_xmm15 as *const _ as usize
               },
               408usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_xmm15)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_rsrv4 as *const _ as usize
               },
               424usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_rsrv4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_reserved1 as *const _ as usize
               },
               520usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_reserved1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__avx_reserved1 as *const _ as usize
               },
               524usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__avx_reserved1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh0 as *const _ as usize
               },
               588usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh1 as *const _ as usize
               },
               604usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh2 as *const _ as usize
               },
               620usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh3 as *const _ as usize
               },
               636usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh4 as *const _ as usize
               },
               652usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh5 as *const _ as usize
               },
               668usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh6 as *const _ as usize
               },
               684usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh7 as *const _ as usize
               },
               700usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh8 as *const _ as usize
               },
               716usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh8)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh9 as *const _ as usize
               },
               732usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh9)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh10 as *const _ as usize
               },
               748usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh10)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh11 as *const _ as usize
               },
               764usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh11)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh12 as *const _ as usize
               },
               780usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh12)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh13 as *const _ as usize
               },
               796usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh13)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh14 as *const _ as usize
               },
               812usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh14)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx_state64)).__fpu_ymmh15 as *const _ as usize
               },
               828usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx_state64),
                       "::",
                       stringify!(__fpu_ymmh15)));
}
#[repr(C)]
pub struct __darwin_x86_avx512_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
    pub __fpu_zmmh8: __darwin_ymm_reg,
    pub __fpu_zmmh9: __darwin_ymm_reg,
    pub __fpu_zmmh10: __darwin_ymm_reg,
    pub __fpu_zmmh11: __darwin_ymm_reg,
    pub __fpu_zmmh12: __darwin_ymm_reg,
    pub __fpu_zmmh13: __darwin_ymm_reg,
    pub __fpu_zmmh14: __darwin_ymm_reg,
    pub __fpu_zmmh15: __darwin_ymm_reg,
    pub __fpu_zmm16: __darwin_zmm_reg,
    pub __fpu_zmm17: __darwin_zmm_reg,
    pub __fpu_zmm18: __darwin_zmm_reg,
    pub __fpu_zmm19: __darwin_zmm_reg,
    pub __fpu_zmm20: __darwin_zmm_reg,
    pub __fpu_zmm21: __darwin_zmm_reg,
    pub __fpu_zmm22: __darwin_zmm_reg,
    pub __fpu_zmm23: __darwin_zmm_reg,
    pub __fpu_zmm24: __darwin_zmm_reg,
    pub __fpu_zmm25: __darwin_zmm_reg,
    pub __fpu_zmm26: __darwin_zmm_reg,
    pub __fpu_zmm27: __darwin_zmm_reg,
    pub __fpu_zmm28: __darwin_zmm_reg,
    pub __fpu_zmm29: __darwin_zmm_reg,
    pub __fpu_zmm30: __darwin_zmm_reg,
    pub __fpu_zmm31: __darwin_zmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx512_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_avx512_state64>(),
               2444usize,
               concat!("Size of: ", stringify!(__darwin_x86_avx512_state64)));
    assert_eq!(::std::mem::align_of::<__darwin_x86_avx512_state64>(),
               4usize,
               concat!("Alignment of ", stringify!(__darwin_x86_avx512_state64)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_reserved as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_reserved)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_fcw as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_fcw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_fsw as *const _ as usize
               },
               10usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_fsw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ftw as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ftw)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_rsrv1 as *const _ as usize
               },
               13usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_rsrv1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_fop as *const _ as usize
               },
               14usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_fop)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ip as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ip)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_cs as *const _ as usize
               },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_cs)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_rsrv2 as *const _ as usize
               },
               22usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_rsrv2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_dp as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_dp)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ds as *const _ as usize
               },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ds)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_rsrv3 as *const _ as usize
               },
               30usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_rsrv3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_mxcsr as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_mxcsr)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_mxcsrmask as *const _ as
                   usize
               },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_mxcsrmask)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_stmm0 as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_stmm0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_stmm1 as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_stmm1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_stmm2 as *const _ as usize
               },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_stmm2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_stmm3 as *const _ as usize
               },
               88usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_stmm3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_stmm4 as *const _ as usize
               },
               104usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_stmm4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_stmm5 as *const _ as usize
               },
               120usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_stmm5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_stmm6 as *const _ as usize
               },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_stmm6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_stmm7 as *const _ as usize
               },
               152usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_stmm7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm0 as *const _ as usize
               },
               168usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm1 as *const _ as usize
               },
               184usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm2 as *const _ as usize
               },
               200usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm3 as *const _ as usize
               },
               216usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm4 as *const _ as usize
               },
               232usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm5 as *const _ as usize
               },
               248usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm6 as *const _ as usize
               },
               264usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm7 as *const _ as usize
               },
               280usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm8 as *const _ as usize
               },
               296usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm8)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm9 as *const _ as usize
               },
               312usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm9)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm10 as *const _ as usize
               },
               328usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm10)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm11 as *const _ as usize
               },
               344usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm11)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm12 as *const _ as usize
               },
               360usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm12)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm13 as *const _ as usize
               },
               376usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm13)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm14 as *const _ as usize
               },
               392usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm14)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_xmm15 as *const _ as usize
               },
               408usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_xmm15)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_rsrv4 as *const _ as usize
               },
               424usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_rsrv4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_reserved1 as *const _ as
                   usize
               },
               520usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_reserved1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__avx_reserved1 as *const _ as
                   usize
               },
               524usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__avx_reserved1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh0 as *const _ as usize
               },
               588usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh1 as *const _ as usize
               },
               604usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh2 as *const _ as usize
               },
               620usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh3 as *const _ as usize
               },
               636usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh4 as *const _ as usize
               },
               652usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh5 as *const _ as usize
               },
               668usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh6 as *const _ as usize
               },
               684usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh7 as *const _ as usize
               },
               700usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh8 as *const _ as usize
               },
               716usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh8)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh9 as *const _ as usize
               },
               732usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh9)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh10 as *const _ as usize
               },
               748usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh10)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh11 as *const _ as usize
               },
               764usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh11)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh12 as *const _ as usize
               },
               780usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh12)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh13 as *const _ as usize
               },
               796usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh13)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh14 as *const _ as usize
               },
               812usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh14)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_ymmh15 as *const _ as usize
               },
               828usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_ymmh15)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_k0 as *const _ as usize
               },
               844usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_k0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_k1 as *const _ as usize
               },
               852usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_k1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_k2 as *const _ as usize
               },
               860usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_k2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_k3 as *const _ as usize
               },
               868usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_k3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_k4 as *const _ as usize
               },
               876usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_k4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_k5 as *const _ as usize
               },
               884usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_k5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_k6 as *const _ as usize
               },
               892usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_k6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_k7 as *const _ as usize
               },
               900usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_k7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh0 as *const _ as usize
               },
               908usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh0)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh1 as *const _ as usize
               },
               940usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh1)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh2 as *const _ as usize
               },
               972usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh2)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh3 as *const _ as usize
               },
               1004usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh3)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh4 as *const _ as usize
               },
               1036usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh4)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh5 as *const _ as usize
               },
               1068usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh5)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh6 as *const _ as usize
               },
               1100usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh6)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh7 as *const _ as usize
               },
               1132usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh7)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh8 as *const _ as usize
               },
               1164usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh8)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh9 as *const _ as usize
               },
               1196usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh9)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh10 as *const _ as usize
               },
               1228usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh10)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh11 as *const _ as usize
               },
               1260usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh11)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh12 as *const _ as usize
               },
               1292usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh12)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh13 as *const _ as usize
               },
               1324usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh13)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh14 as *const _ as usize
               },
               1356usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh14)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmmh15 as *const _ as usize
               },
               1388usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmmh15)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm16 as *const _ as usize
               },
               1420usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm16)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm17 as *const _ as usize
               },
               1484usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm17)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm18 as *const _ as usize
               },
               1548usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm18)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm19 as *const _ as usize
               },
               1612usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm19)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm20 as *const _ as usize
               },
               1676usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm20)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm21 as *const _ as usize
               },
               1740usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm21)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm22 as *const _ as usize
               },
               1804usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm22)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm23 as *const _ as usize
               },
               1868usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm23)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm24 as *const _ as usize
               },
               1932usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm24)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm25 as *const _ as usize
               },
               1996usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm25)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm26 as *const _ as usize
               },
               2060usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm26)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm27 as *const _ as usize
               },
               2124usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm27)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm28 as *const _ as usize
               },
               2188usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm28)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm29 as *const _ as usize
               },
               2252usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm29)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm30 as *const _ as usize
               },
               2316usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm30)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_avx512_state64)).__fpu_zmm31 as *const _ as usize
               },
               2380usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_avx512_state64),
                       "::",
                       stringify!(__fpu_zmm31)));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_exception_state64>(),
               16usize,
               concat!("Size of: ", stringify!(__darwin_x86_exception_state64)));
    assert_eq!(::std::mem::align_of::<__darwin_x86_exception_state64>(),
               8usize,
               concat!("Alignment of ", stringify!(__darwin_x86_exception_state64)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_exception_state64)).__trapno as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_exception_state64),
                       "::",
                       stringify!(__trapno)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_exception_state64)).__cpu as *const _ as usize
               },
               2usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_exception_state64),
                       "::",
                       stringify!(__cpu)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_exception_state64)).__err as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_exception_state64),
                       "::",
                       stringify!(__err)));
    assert_eq!(unsafe {
                   &(*(0 as *const __darwin_x86_exception_state64)).__faultvaddr as *const _ as
                   usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_exception_state64),
                       "::",
                       stringify!(__faultvaddr)));
}
impl Clone for __darwin_x86_exception_state64 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_debug_state64>(),
               64usize,
               concat!("Size of: ", stringify!(__darwin_x86_debug_state64)));
    assert_eq!(::std::mem::align_of::<__darwin_x86_debug_state64>(),
               8usize,
               concat!("Alignment of ", stringify!(__darwin_x86_debug_state64)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state64)).__dr0 as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state64),
                       "::",
                       stringify!(__dr0)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state64)).__dr1 as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state64),
                       "::",
                       stringify!(__dr1)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state64)).__dr2 as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state64),
                       "::",
                       stringify!(__dr2)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state64)).__dr3 as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state64),
                       "::",
                       stringify!(__dr3)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state64)).__dr4 as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state64),
                       "::",
                       stringify!(__dr4)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state64)).__dr5 as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state64),
                       "::",
                       stringify!(__dr5)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state64)).__dr6 as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state64),
                       "::",
                       stringify!(__dr6)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_debug_state64)).__dr7 as *const _ as usize },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_debug_state64),
                       "::",
                       stringify!(__dr7)));
}
impl Clone for __darwin_x86_debug_state64 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_x86_cpmu_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_cpmu_state64>(),
               128usize,
               concat!("Size of: ", stringify!(__darwin_x86_cpmu_state64)));
    assert_eq!(::std::mem::align_of::<__darwin_x86_cpmu_state64>(),
               8usize,
               concat!("Alignment of ", stringify!(__darwin_x86_cpmu_state64)));
    assert_eq!(unsafe { &(*(0 as *const __darwin_x86_cpmu_state64)).__ctrs as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__darwin_x86_cpmu_state64),
                       "::",
                       stringify!(__ctrs)));
}
impl Clone for __darwin_x86_cpmu_state64 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct x86_state_hdr {
    pub flavor: u32,
    pub count: u32,
}
#[test]
fn bindgen_test_layout_x86_state_hdr() {
    assert_eq!(::std::mem::size_of::<x86_state_hdr>(),
               8usize,
               concat!("Size of: ", stringify!(x86_state_hdr)));
    assert_eq!(::std::mem::align_of::<x86_state_hdr>(),
               4usize,
               concat!("Alignment of ", stringify!(x86_state_hdr)));
    assert_eq!(unsafe { &(*(0 as *const x86_state_hdr)).flavor as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_state_hdr),
                       "::",
                       stringify!(flavor)));
    assert_eq!(unsafe { &(*(0 as *const x86_state_hdr)).count as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(x86_state_hdr),
                       "::",
                       stringify!(count)));
}
impl Clone for x86_state_hdr {
    fn clone(&self) -> Self {
        *self
    }
}
pub type x86_state_hdr_t = x86_state_hdr;
pub type i386_thread_state_t = __darwin_i386_thread_state;
pub type x86_thread_state32_t = __darwin_i386_thread_state;
pub type i386_float_state_t = __darwin_i386_float_state;
pub type x86_float_state32_t = __darwin_i386_float_state;
pub type x86_avx_state32_t = __darwin_i386_avx_state;
pub type x86_avx512_state32_t = __darwin_i386_avx512_state;
pub type i386_exception_state_t = __darwin_i386_exception_state;
pub type x86_exception_state32_t = __darwin_i386_exception_state;
pub type x86_debug_state32_t = __darwin_x86_debug_state32;
pub type x86_thread_state64_t = __darwin_x86_thread_state64;
pub type x86_float_state64_t = __darwin_x86_float_state64;
pub type x86_avx_state64_t = __darwin_x86_avx_state64;
pub type x86_avx512_state64_t = __darwin_x86_avx512_state64;
pub type x86_exception_state64_t = __darwin_x86_exception_state64;
pub type x86_debug_state64_t = __darwin_x86_debug_state64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct x86_thread_state {
    pub tsh: x86_state_hdr_t,
    pub uts: x86_thread_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct x86_thread_state__bindgen_ty_1 {
    pub ts32: __BindgenUnionField<x86_thread_state32_t>,
    pub ts64: __BindgenUnionField<x86_thread_state64_t>,
    pub bindgen_union_field: [u64; 21usize],
}
#[test]
fn bindgen_test_layout_x86_thread_state__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<x86_thread_state__bindgen_ty_1>(),
               168usize,
               concat!("Size of: ", stringify!(x86_thread_state__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<x86_thread_state__bindgen_ty_1>(),
               8usize,
               concat!("Alignment of ", stringify!(x86_thread_state__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const x86_thread_state__bindgen_ty_1)).ts32 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_thread_state__bindgen_ty_1),
                       "::",
                       stringify!(ts32)));
    assert_eq!(unsafe {
                   &(*(0 as *const x86_thread_state__bindgen_ty_1)).ts64 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_thread_state__bindgen_ty_1),
                       "::",
                       stringify!(ts64)));
}
impl Clone for x86_thread_state__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_x86_thread_state() {
    assert_eq!(::std::mem::size_of::<x86_thread_state>(),
               176usize,
               concat!("Size of: ", stringify!(x86_thread_state)));
    assert_eq!(::std::mem::align_of::<x86_thread_state>(),
               8usize,
               concat!("Alignment of ", stringify!(x86_thread_state)));
    assert_eq!(unsafe { &(*(0 as *const x86_thread_state)).tsh as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_thread_state),
                       "::",
                       stringify!(tsh)));
    assert_eq!(unsafe { &(*(0 as *const x86_thread_state)).uts as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(x86_thread_state),
                       "::",
                       stringify!(uts)));
}
impl Clone for x86_thread_state {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct x86_float_state {
    pub fsh: x86_state_hdr_t,
    pub ufs: x86_float_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct x86_float_state__bindgen_ty_1 {
    pub fs32: __BindgenUnionField<x86_float_state32_t>,
    pub fs64: __BindgenUnionField<x86_float_state64_t>,
    pub bindgen_union_field: [u32; 131usize],
}
#[test]
fn bindgen_test_layout_x86_float_state__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<x86_float_state__bindgen_ty_1>(),
               524usize,
               concat!("Size of: ", stringify!(x86_float_state__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<x86_float_state__bindgen_ty_1>(),
               4usize,
               concat!("Alignment of ", stringify!(x86_float_state__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const x86_float_state__bindgen_ty_1)).fs32 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_float_state__bindgen_ty_1),
                       "::",
                       stringify!(fs32)));
    assert_eq!(unsafe {
                   &(*(0 as *const x86_float_state__bindgen_ty_1)).fs64 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_float_state__bindgen_ty_1),
                       "::",
                       stringify!(fs64)));
}
impl Clone for x86_float_state__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_x86_float_state() {
    assert_eq!(::std::mem::size_of::<x86_float_state>(),
               532usize,
               concat!("Size of: ", stringify!(x86_float_state)));
    assert_eq!(::std::mem::align_of::<x86_float_state>(),
               4usize,
               concat!("Alignment of ", stringify!(x86_float_state)));
    assert_eq!(unsafe { &(*(0 as *const x86_float_state)).fsh as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_float_state),
                       "::",
                       stringify!(fsh)));
    assert_eq!(unsafe { &(*(0 as *const x86_float_state)).ufs as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(x86_float_state),
                       "::",
                       stringify!(ufs)));
}
impl Clone for x86_float_state {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct x86_exception_state {
    pub esh: x86_state_hdr_t,
    pub ues: x86_exception_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct x86_exception_state__bindgen_ty_1 {
    pub es32: __BindgenUnionField<x86_exception_state32_t>,
    pub es64: __BindgenUnionField<x86_exception_state64_t>,
    pub bindgen_union_field: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_x86_exception_state__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<x86_exception_state__bindgen_ty_1>(),
               16usize,
               concat!("Size of: ", stringify!(x86_exception_state__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<x86_exception_state__bindgen_ty_1>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(x86_exception_state__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const x86_exception_state__bindgen_ty_1)).es32 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_exception_state__bindgen_ty_1),
                       "::",
                       stringify!(es32)));
    assert_eq!(unsafe {
                   &(*(0 as *const x86_exception_state__bindgen_ty_1)).es64 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_exception_state__bindgen_ty_1),
                       "::",
                       stringify!(es64)));
}
impl Clone for x86_exception_state__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_x86_exception_state() {
    assert_eq!(::std::mem::size_of::<x86_exception_state>(),
               24usize,
               concat!("Size of: ", stringify!(x86_exception_state)));
    assert_eq!(::std::mem::align_of::<x86_exception_state>(),
               8usize,
               concat!("Alignment of ", stringify!(x86_exception_state)));
    assert_eq!(unsafe { &(*(0 as *const x86_exception_state)).esh as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_exception_state),
                       "::",
                       stringify!(esh)));
    assert_eq!(unsafe { &(*(0 as *const x86_exception_state)).ues as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(x86_exception_state),
                       "::",
                       stringify!(ues)));
}
impl Clone for x86_exception_state {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct x86_debug_state {
    pub dsh: x86_state_hdr_t,
    pub uds: x86_debug_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct x86_debug_state__bindgen_ty_1 {
    pub ds32: __BindgenUnionField<x86_debug_state32_t>,
    pub ds64: __BindgenUnionField<x86_debug_state64_t>,
    pub bindgen_union_field: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_x86_debug_state__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<x86_debug_state__bindgen_ty_1>(),
               64usize,
               concat!("Size of: ", stringify!(x86_debug_state__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<x86_debug_state__bindgen_ty_1>(),
               8usize,
               concat!("Alignment of ", stringify!(x86_debug_state__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const x86_debug_state__bindgen_ty_1)).ds32 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_debug_state__bindgen_ty_1),
                       "::",
                       stringify!(ds32)));
    assert_eq!(unsafe {
                   &(*(0 as *const x86_debug_state__bindgen_ty_1)).ds64 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_debug_state__bindgen_ty_1),
                       "::",
                       stringify!(ds64)));
}
impl Clone for x86_debug_state__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_x86_debug_state() {
    assert_eq!(::std::mem::size_of::<x86_debug_state>(),
               72usize,
               concat!("Size of: ", stringify!(x86_debug_state)));
    assert_eq!(::std::mem::align_of::<x86_debug_state>(),
               8usize,
               concat!("Alignment of ", stringify!(x86_debug_state)));
    assert_eq!(unsafe { &(*(0 as *const x86_debug_state)).dsh as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_debug_state),
                       "::",
                       stringify!(dsh)));
    assert_eq!(unsafe { &(*(0 as *const x86_debug_state)).uds as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(x86_debug_state),
                       "::",
                       stringify!(uds)));
}
impl Clone for x86_debug_state {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct x86_avx_state {
    pub ash: x86_state_hdr_t,
    pub ufs: x86_avx_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct x86_avx_state__bindgen_ty_1 {
    pub as32: __BindgenUnionField<x86_avx_state32_t>,
    pub as64: __BindgenUnionField<x86_avx_state64_t>,
    pub bindgen_union_field: [u32; 211usize],
}
#[test]
fn bindgen_test_layout_x86_avx_state__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<x86_avx_state__bindgen_ty_1>(),
               844usize,
               concat!("Size of: ", stringify!(x86_avx_state__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<x86_avx_state__bindgen_ty_1>(),
               4usize,
               concat!("Alignment of ", stringify!(x86_avx_state__bindgen_ty_1)));
    assert_eq!(unsafe { &(*(0 as *const x86_avx_state__bindgen_ty_1)).as32 as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_avx_state__bindgen_ty_1),
                       "::",
                       stringify!(as32)));
    assert_eq!(unsafe { &(*(0 as *const x86_avx_state__bindgen_ty_1)).as64 as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_avx_state__bindgen_ty_1),
                       "::",
                       stringify!(as64)));
}
impl Clone for x86_avx_state__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_x86_avx_state() {
    assert_eq!(::std::mem::size_of::<x86_avx_state>(),
               852usize,
               concat!("Size of: ", stringify!(x86_avx_state)));
    assert_eq!(::std::mem::align_of::<x86_avx_state>(),
               4usize,
               concat!("Alignment of ", stringify!(x86_avx_state)));
    assert_eq!(unsafe { &(*(0 as *const x86_avx_state)).ash as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_avx_state),
                       "::",
                       stringify!(ash)));
    assert_eq!(unsafe { &(*(0 as *const x86_avx_state)).ufs as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(x86_avx_state),
                       "::",
                       stringify!(ufs)));
}
impl Clone for x86_avx_state {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct x86_avx512_state {
    pub ash: x86_state_hdr_t,
    pub ufs: x86_avx512_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct x86_avx512_state__bindgen_ty_1 {
    pub as32: __BindgenUnionField<x86_avx512_state32_t>,
    pub as64: __BindgenUnionField<x86_avx512_state64_t>,
    pub bindgen_union_field: [u32; 611usize],
}
#[test]
fn bindgen_test_layout_x86_avx512_state__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<x86_avx512_state__bindgen_ty_1>(),
               2444usize,
               concat!("Size of: ", stringify!(x86_avx512_state__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<x86_avx512_state__bindgen_ty_1>(),
               4usize,
               concat!("Alignment of ", stringify!(x86_avx512_state__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const x86_avx512_state__bindgen_ty_1)).as32 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_avx512_state__bindgen_ty_1),
                       "::",
                       stringify!(as32)));
    assert_eq!(unsafe {
                   &(*(0 as *const x86_avx512_state__bindgen_ty_1)).as64 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_avx512_state__bindgen_ty_1),
                       "::",
                       stringify!(as64)));
}
impl Clone for x86_avx512_state__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_x86_avx512_state() {
    assert_eq!(::std::mem::size_of::<x86_avx512_state>(),
               2452usize,
               concat!("Size of: ", stringify!(x86_avx512_state)));
    assert_eq!(::std::mem::align_of::<x86_avx512_state>(),
               4usize,
               concat!("Alignment of ", stringify!(x86_avx512_state)));
    assert_eq!(unsafe { &(*(0 as *const x86_avx512_state)).ash as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(x86_avx512_state),
                       "::",
                       stringify!(ash)));
    assert_eq!(unsafe { &(*(0 as *const x86_avx512_state)).ufs as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(x86_avx512_state),
                       "::",
                       stringify!(ufs)));
}
impl Clone for x86_avx512_state {
    fn clone(&self) -> Self {
        *self
    }
}
pub type x86_thread_state_t = x86_thread_state;
pub type x86_float_state_t = x86_float_state;
pub type x86_exception_state_t = x86_exception_state;
pub type x86_debug_state_t = x86_debug_state;
pub type x86_avx_state_t = x86_avx_state;
pub type x86_avx512_state_t = x86_avx512_state;
pub type thread_state_t = *mut natural_t;
pub type thread_state_data_t = [natural_t; 614usize];
pub type thread_state_flavor_t = ::std::os::raw::c_int;
pub type thread_state_flavor_array_t = *mut thread_state_flavor_t;
pub type exception_type_t = ::std::os::raw::c_int;
pub type exception_data_type_t = integer_t;
pub type mach_exception_data_type_t = i64;
pub type exception_behavior_t = ::std::os::raw::c_int;
pub type exception_data_t = *mut exception_data_type_t;
pub type mach_exception_data_t = *mut mach_exception_data_type_t;
pub type exception_mask_t = ::std::os::raw::c_uint;
pub type exception_mask_array_t = *mut exception_mask_t;
pub type exception_behavior_array_t = *mut exception_behavior_t;
pub type exception_flavor_array_t = *mut thread_state_flavor_t;
pub type exception_port_array_t = *mut mach_port_t;
pub type mach_exception_code_t = mach_exception_data_type_t;
pub type mach_exception_subcode_t = mach_exception_data_type_t;
pub type uuid_t = __darwin_uuid_t;
pub type mach_voucher_t = mach_port_t;
pub type mach_voucher_name_t = mach_port_name_t;
pub type mach_voucher_name_array_t = *mut mach_voucher_name_t;
pub type ipc_voucher_t = mach_voucher_t;
pub type mach_voucher_selector_t = u32;
pub type mach_voucher_attr_key_t = u32;
pub type mach_voucher_attr_key_array_t = *mut mach_voucher_attr_key_t;
pub type mach_voucher_attr_content_t = *mut u8;
pub type mach_voucher_attr_content_size_t = u32;
pub type mach_voucher_attr_command_t = u32;
pub type mach_voucher_attr_recipe_command_t = u32;
pub type mach_voucher_attr_recipe_command_array_t = *mut mach_voucher_attr_recipe_command_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_voucher_attr_recipe_data {
    pub key: mach_voucher_attr_key_t,
    pub command: mach_voucher_attr_recipe_command_t,
    pub previous_voucher: mach_voucher_name_t,
    pub content_size: mach_voucher_attr_content_size_t,
    pub content: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_mach_voucher_attr_recipe_data() {
    assert_eq!(::std::mem::size_of::<mach_voucher_attr_recipe_data>(),
               16usize,
               concat!("Size of: ", stringify!(mach_voucher_attr_recipe_data)));
    assert_eq!(::std::mem::align_of::<mach_voucher_attr_recipe_data>(),
               1usize,
               concat!("Alignment of ", stringify!(mach_voucher_attr_recipe_data)));
}
impl Clone for mach_voucher_attr_recipe_data {
    fn clone(&self) -> Self {
        *self
    }
}
pub type mach_voucher_attr_recipe_data_t = mach_voucher_attr_recipe_data;
pub type mach_voucher_attr_recipe_t = *mut mach_voucher_attr_recipe_data_t;
pub type mach_voucher_attr_recipe_size_t = mach_msg_type_number_t;
pub type mach_voucher_attr_raw_recipe_t = *mut u8;
pub type mach_voucher_attr_raw_recipe_array_t = mach_voucher_attr_raw_recipe_t;
pub type mach_voucher_attr_raw_recipe_size_t = mach_msg_type_number_t;
pub type mach_voucher_attr_raw_recipe_array_size_t = mach_msg_type_number_t;
pub type mach_voucher_attr_manager_t = mach_port_t;
pub type mach_voucher_attr_control_t = mach_port_t;
pub type ipc_voucher_attr_manager_t = mach_port_t;
pub type ipc_voucher_attr_control_t = mach_port_t;
pub type mach_voucher_attr_value_handle_t = u64;
pub type mach_voucher_attr_value_handle_array_t = *mut mach_voucher_attr_value_handle_t;
pub type mach_voucher_attr_value_handle_array_size_t = mach_msg_type_number_t;
pub type mach_voucher_attr_value_reference_t = u32;
pub type mach_voucher_attr_value_flags_t = u32;
pub type mach_voucher_attr_control_flags_t = u32;
pub type mach_voucher_attr_importance_refs = u32;
pub type processor_info_t = *mut integer_t;
pub type processor_info_array_t = *mut integer_t;
pub type processor_info_data_t = [integer_t; 1024usize];
pub type processor_set_info_t = *mut integer_t;
pub type processor_set_info_data_t = [integer_t; 1024usize];
pub type processor_flavor_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct processor_basic_info {
    pub cpu_type: cpu_type_t,
    pub cpu_subtype: cpu_subtype_t,
    pub running: boolean_t,
    pub slot_num: ::std::os::raw::c_int,
    pub is_master: boolean_t,
}
#[test]
fn bindgen_test_layout_processor_basic_info() {
    assert_eq!(::std::mem::size_of::<processor_basic_info>(),
               20usize,
               concat!("Size of: ", stringify!(processor_basic_info)));
    assert_eq!(::std::mem::align_of::<processor_basic_info>(),
               4usize,
               concat!("Alignment of ", stringify!(processor_basic_info)));
    assert_eq!(unsafe { &(*(0 as *const processor_basic_info)).cpu_type as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(processor_basic_info),
                       "::",
                       stringify!(cpu_type)));
    assert_eq!(unsafe { &(*(0 as *const processor_basic_info)).cpu_subtype as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(processor_basic_info),
                       "::",
                       stringify!(cpu_subtype)));
    assert_eq!(unsafe { &(*(0 as *const processor_basic_info)).running as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(processor_basic_info),
                       "::",
                       stringify!(running)));
    assert_eq!(unsafe { &(*(0 as *const processor_basic_info)).slot_num as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(processor_basic_info),
                       "::",
                       stringify!(slot_num)));
    assert_eq!(unsafe { &(*(0 as *const processor_basic_info)).is_master as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(processor_basic_info),
                       "::",
                       stringify!(is_master)));
}
impl Clone for processor_basic_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type processor_basic_info_data_t = processor_basic_info;
pub type processor_basic_info_t = *mut processor_basic_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct processor_cpu_load_info {
    pub cpu_ticks: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_processor_cpu_load_info() {
    assert_eq!(::std::mem::size_of::<processor_cpu_load_info>(),
               16usize,
               concat!("Size of: ", stringify!(processor_cpu_load_info)));
    assert_eq!(::std::mem::align_of::<processor_cpu_load_info>(),
               4usize,
               concat!("Alignment of ", stringify!(processor_cpu_load_info)));
    assert_eq!(unsafe { &(*(0 as *const processor_cpu_load_info)).cpu_ticks as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(processor_cpu_load_info),
                       "::",
                       stringify!(cpu_ticks)));
}
impl Clone for processor_cpu_load_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type processor_cpu_load_info_data_t = processor_cpu_load_info;
pub type processor_cpu_load_info_t = *mut processor_cpu_load_info;
pub type processor_set_flavor_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct processor_set_basic_info {
    pub processor_count: ::std::os::raw::c_int,
    pub default_policy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_processor_set_basic_info() {
    assert_eq!(::std::mem::size_of::<processor_set_basic_info>(),
               8usize,
               concat!("Size of: ", stringify!(processor_set_basic_info)));
    assert_eq!(::std::mem::align_of::<processor_set_basic_info>(),
               4usize,
               concat!("Alignment of ", stringify!(processor_set_basic_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const processor_set_basic_info)).processor_count as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(processor_set_basic_info),
                       "::",
                       stringify!(processor_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const processor_set_basic_info)).default_policy as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(processor_set_basic_info),
                       "::",
                       stringify!(default_policy)));
}
impl Clone for processor_set_basic_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type processor_set_basic_info_data_t = processor_set_basic_info;
pub type processor_set_basic_info_t = *mut processor_set_basic_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct processor_set_load_info {
    pub task_count: ::std::os::raw::c_int,
    pub thread_count: ::std::os::raw::c_int,
    pub load_average: integer_t,
    pub mach_factor: integer_t,
}
#[test]
fn bindgen_test_layout_processor_set_load_info() {
    assert_eq!(::std::mem::size_of::<processor_set_load_info>(),
               16usize,
               concat!("Size of: ", stringify!(processor_set_load_info)));
    assert_eq!(::std::mem::align_of::<processor_set_load_info>(),
               4usize,
               concat!("Alignment of ", stringify!(processor_set_load_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const processor_set_load_info)).task_count as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(processor_set_load_info),
                       "::",
                       stringify!(task_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const processor_set_load_info)).thread_count as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(processor_set_load_info),
                       "::",
                       stringify!(thread_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const processor_set_load_info)).load_average as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(processor_set_load_info),
                       "::",
                       stringify!(load_average)));
    assert_eq!(unsafe {
                   &(*(0 as *const processor_set_load_info)).mach_factor as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(processor_set_load_info),
                       "::",
                       stringify!(mach_factor)));
}
impl Clone for processor_set_load_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type processor_set_load_info_data_t = processor_set_load_info;
pub type processor_set_load_info_t = *mut processor_set_load_info;
pub type policy_t = ::std::os::raw::c_int;
pub type policy_info_t = *mut integer_t;
pub type policy_base_t = *mut integer_t;
pub type policy_limit_t = *mut integer_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct policy_timeshare_base {
    pub base_priority: integer_t,
}
#[test]
fn bindgen_test_layout_policy_timeshare_base() {
    assert_eq!(::std::mem::size_of::<policy_timeshare_base>(),
               4usize,
               concat!("Size of: ", stringify!(policy_timeshare_base)));
    assert_eq!(::std::mem::align_of::<policy_timeshare_base>(),
               4usize,
               concat!("Alignment of ", stringify!(policy_timeshare_base)));
    assert_eq!(unsafe {
                   &(*(0 as *const policy_timeshare_base)).base_priority as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(policy_timeshare_base),
                       "::",
                       stringify!(base_priority)));
}
impl Clone for policy_timeshare_base {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct policy_timeshare_limit {
    pub max_priority: integer_t,
}
#[test]
fn bindgen_test_layout_policy_timeshare_limit() {
    assert_eq!(::std::mem::size_of::<policy_timeshare_limit>(),
               4usize,
               concat!("Size of: ", stringify!(policy_timeshare_limit)));
    assert_eq!(::std::mem::align_of::<policy_timeshare_limit>(),
               4usize,
               concat!("Alignment of ", stringify!(policy_timeshare_limit)));
    assert_eq!(unsafe {
                   &(*(0 as *const policy_timeshare_limit)).max_priority as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(policy_timeshare_limit),
                       "::",
                       stringify!(max_priority)));
}
impl Clone for policy_timeshare_limit {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct policy_timeshare_info {
    pub max_priority: integer_t,
    pub base_priority: integer_t,
    pub cur_priority: integer_t,
    pub depressed: boolean_t,
    pub depress_priority: integer_t,
}
#[test]
fn bindgen_test_layout_policy_timeshare_info() {
    assert_eq!(::std::mem::size_of::<policy_timeshare_info>(),
               20usize,
               concat!("Size of: ", stringify!(policy_timeshare_info)));
    assert_eq!(::std::mem::align_of::<policy_timeshare_info>(),
               4usize,
               concat!("Alignment of ", stringify!(policy_timeshare_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const policy_timeshare_info)).max_priority as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(policy_timeshare_info),
                       "::",
                       stringify!(max_priority)));
    assert_eq!(unsafe {
                   &(*(0 as *const policy_timeshare_info)).base_priority as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(policy_timeshare_info),
                       "::",
                       stringify!(base_priority)));
    assert_eq!(unsafe {
                   &(*(0 as *const policy_timeshare_info)).cur_priority as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(policy_timeshare_info),
                       "::",
                       stringify!(cur_priority)));
    assert_eq!(unsafe { &(*(0 as *const policy_timeshare_info)).depressed as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(policy_timeshare_info),
                       "::",
                       stringify!(depressed)));
    assert_eq!(unsafe {
                   &(*(0 as *const policy_timeshare_info)).depress_priority as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(policy_timeshare_info),
                       "::",
                       stringify!(depress_priority)));
}
impl Clone for policy_timeshare_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type policy_timeshare_base_t = *mut policy_timeshare_base;
pub type policy_timeshare_limit_t = *mut policy_timeshare_limit;
pub type policy_timeshare_info_t = *mut policy_timeshare_info;
pub type policy_timeshare_base_data_t = policy_timeshare_base;
pub type policy_timeshare_limit_data_t = policy_timeshare_limit;
pub type policy_timeshare_info_data_t = policy_timeshare_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct policy_rr_base {
    pub base_priority: integer_t,
    pub quantum: integer_t,
}
#[test]
fn bindgen_test_layout_policy_rr_base() {
    assert_eq!(::std::mem::size_of::<policy_rr_base>(),
               8usize,
               concat!("Size of: ", stringify!(policy_rr_base)));
    assert_eq!(::std::mem::align_of::<policy_rr_base>(),
               4usize,
               concat!("Alignment of ", stringify!(policy_rr_base)));
    assert_eq!(unsafe { &(*(0 as *const policy_rr_base)).base_priority as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(policy_rr_base),
                       "::",
                       stringify!(base_priority)));
    assert_eq!(unsafe { &(*(0 as *const policy_rr_base)).quantum as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(policy_rr_base),
                       "::",
                       stringify!(quantum)));
}
impl Clone for policy_rr_base {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct policy_rr_limit {
    pub max_priority: integer_t,
}
#[test]
fn bindgen_test_layout_policy_rr_limit() {
    assert_eq!(::std::mem::size_of::<policy_rr_limit>(),
               4usize,
               concat!("Size of: ", stringify!(policy_rr_limit)));
    assert_eq!(::std::mem::align_of::<policy_rr_limit>(),
               4usize,
               concat!("Alignment of ", stringify!(policy_rr_limit)));
    assert_eq!(unsafe { &(*(0 as *const policy_rr_limit)).max_priority as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(policy_rr_limit),
                       "::",
                       stringify!(max_priority)));
}
impl Clone for policy_rr_limit {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct policy_rr_info {
    pub max_priority: integer_t,
    pub base_priority: integer_t,
    pub quantum: integer_t,
    pub depressed: boolean_t,
    pub depress_priority: integer_t,
}
#[test]
fn bindgen_test_layout_policy_rr_info() {
    assert_eq!(::std::mem::size_of::<policy_rr_info>(),
               20usize,
               concat!("Size of: ", stringify!(policy_rr_info)));
    assert_eq!(::std::mem::align_of::<policy_rr_info>(),
               4usize,
               concat!("Alignment of ", stringify!(policy_rr_info)));
    assert_eq!(unsafe { &(*(0 as *const policy_rr_info)).max_priority as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(policy_rr_info),
                       "::",
                       stringify!(max_priority)));
    assert_eq!(unsafe { &(*(0 as *const policy_rr_info)).base_priority as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(policy_rr_info),
                       "::",
                       stringify!(base_priority)));
    assert_eq!(unsafe { &(*(0 as *const policy_rr_info)).quantum as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(policy_rr_info),
                       "::",
                       stringify!(quantum)));
    assert_eq!(unsafe { &(*(0 as *const policy_rr_info)).depressed as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(policy_rr_info),
                       "::",
                       stringify!(depressed)));
    assert_eq!(unsafe { &(*(0 as *const policy_rr_info)).depress_priority as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(policy_rr_info),
                       "::",
                       stringify!(depress_priority)));
}
impl Clone for policy_rr_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type policy_rr_base_t = *mut policy_rr_base;
pub type policy_rr_limit_t = *mut policy_rr_limit;
pub type policy_rr_info_t = *mut policy_rr_info;
pub type policy_rr_base_data_t = policy_rr_base;
pub type policy_rr_limit_data_t = policy_rr_limit;
pub type policy_rr_info_data_t = policy_rr_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct policy_fifo_base {
    pub base_priority: integer_t,
}
#[test]
fn bindgen_test_layout_policy_fifo_base() {
    assert_eq!(::std::mem::size_of::<policy_fifo_base>(),
               4usize,
               concat!("Size of: ", stringify!(policy_fifo_base)));
    assert_eq!(::std::mem::align_of::<policy_fifo_base>(),
               4usize,
               concat!("Alignment of ", stringify!(policy_fifo_base)));
    assert_eq!(unsafe { &(*(0 as *const policy_fifo_base)).base_priority as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(policy_fifo_base),
                       "::",
                       stringify!(base_priority)));
}
impl Clone for policy_fifo_base {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct policy_fifo_limit {
    pub max_priority: integer_t,
}
#[test]
fn bindgen_test_layout_policy_fifo_limit() {
    assert_eq!(::std::mem::size_of::<policy_fifo_limit>(),
               4usize,
               concat!("Size of: ", stringify!(policy_fifo_limit)));
    assert_eq!(::std::mem::align_of::<policy_fifo_limit>(),
               4usize,
               concat!("Alignment of ", stringify!(policy_fifo_limit)));
    assert_eq!(unsafe { &(*(0 as *const policy_fifo_limit)).max_priority as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(policy_fifo_limit),
                       "::",
                       stringify!(max_priority)));
}
impl Clone for policy_fifo_limit {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct policy_fifo_info {
    pub max_priority: integer_t,
    pub base_priority: integer_t,
    pub depressed: boolean_t,
    pub depress_priority: integer_t,
}
#[test]
fn bindgen_test_layout_policy_fifo_info() {
    assert_eq!(::std::mem::size_of::<policy_fifo_info>(),
               16usize,
               concat!("Size of: ", stringify!(policy_fifo_info)));
    assert_eq!(::std::mem::align_of::<policy_fifo_info>(),
               4usize,
               concat!("Alignment of ", stringify!(policy_fifo_info)));
    assert_eq!(unsafe { &(*(0 as *const policy_fifo_info)).max_priority as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(policy_fifo_info),
                       "::",
                       stringify!(max_priority)));
    assert_eq!(unsafe { &(*(0 as *const policy_fifo_info)).base_priority as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(policy_fifo_info),
                       "::",
                       stringify!(base_priority)));
    assert_eq!(unsafe { &(*(0 as *const policy_fifo_info)).depressed as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(policy_fifo_info),
                       "::",
                       stringify!(depressed)));
    assert_eq!(unsafe { &(*(0 as *const policy_fifo_info)).depress_priority as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(policy_fifo_info),
                       "::",
                       stringify!(depress_priority)));
}
impl Clone for policy_fifo_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type policy_fifo_base_t = *mut policy_fifo_base;
pub type policy_fifo_limit_t = *mut policy_fifo_limit;
pub type policy_fifo_info_t = *mut policy_fifo_info;
pub type policy_fifo_base_data_t = policy_fifo_base;
pub type policy_fifo_limit_data_t = policy_fifo_limit;
pub type policy_fifo_info_data_t = policy_fifo_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct policy_bases {
    pub ts: policy_timeshare_base_data_t,
    pub rr: policy_rr_base_data_t,
    pub fifo: policy_fifo_base_data_t,
}
#[test]
fn bindgen_test_layout_policy_bases() {
    assert_eq!(::std::mem::size_of::<policy_bases>(),
               16usize,
               concat!("Size of: ", stringify!(policy_bases)));
    assert_eq!(::std::mem::align_of::<policy_bases>(),
               4usize,
               concat!("Alignment of ", stringify!(policy_bases)));
    assert_eq!(unsafe { &(*(0 as *const policy_bases)).ts as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(policy_bases),
                       "::",
                       stringify!(ts)));
    assert_eq!(unsafe { &(*(0 as *const policy_bases)).rr as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(policy_bases),
                       "::",
                       stringify!(rr)));
    assert_eq!(unsafe { &(*(0 as *const policy_bases)).fifo as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(policy_bases),
                       "::",
                       stringify!(fifo)));
}
impl Clone for policy_bases {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct policy_limits {
    pub ts: policy_timeshare_limit_data_t,
    pub rr: policy_rr_limit_data_t,
    pub fifo: policy_fifo_limit_data_t,
}
#[test]
fn bindgen_test_layout_policy_limits() {
    assert_eq!(::std::mem::size_of::<policy_limits>(),
               12usize,
               concat!("Size of: ", stringify!(policy_limits)));
    assert_eq!(::std::mem::align_of::<policy_limits>(),
               4usize,
               concat!("Alignment of ", stringify!(policy_limits)));
    assert_eq!(unsafe { &(*(0 as *const policy_limits)).ts as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(policy_limits),
                       "::",
                       stringify!(ts)));
    assert_eq!(unsafe { &(*(0 as *const policy_limits)).rr as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(policy_limits),
                       "::",
                       stringify!(rr)));
    assert_eq!(unsafe { &(*(0 as *const policy_limits)).fifo as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(policy_limits),
                       "::",
                       stringify!(fifo)));
}
impl Clone for policy_limits {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct policy_infos {
    pub ts: policy_timeshare_info_data_t,
    pub rr: policy_rr_info_data_t,
    pub fifo: policy_fifo_info_data_t,
}
#[test]
fn bindgen_test_layout_policy_infos() {
    assert_eq!(::std::mem::size_of::<policy_infos>(),
               56usize,
               concat!("Size of: ", stringify!(policy_infos)));
    assert_eq!(::std::mem::align_of::<policy_infos>(),
               4usize,
               concat!("Alignment of ", stringify!(policy_infos)));
    assert_eq!(unsafe { &(*(0 as *const policy_infos)).ts as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(policy_infos),
                       "::",
                       stringify!(ts)));
    assert_eq!(unsafe { &(*(0 as *const policy_infos)).rr as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(policy_infos),
                       "::",
                       stringify!(rr)));
    assert_eq!(unsafe { &(*(0 as *const policy_infos)).fifo as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(policy_infos),
                       "::",
                       stringify!(fifo)));
}
impl Clone for policy_infos {
    fn clone(&self) -> Self {
        *self
    }
}
pub type policy_base_data_t = policy_bases;
pub type policy_limit_data_t = policy_limits;
pub type policy_info_data_t = policy_infos;
pub type task_flavor_t = natural_t;
pub type task_info_t = *mut integer_t;
pub type task_info_data_t = [integer_t; 1024usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_basic_info_32 {
    pub suspend_count: integer_t,
    pub virtual_size: natural_t,
    pub resident_size: natural_t,
    pub user_time: time_value_t,
    pub system_time: time_value_t,
    pub policy: policy_t,
}
#[test]
fn bindgen_test_layout_task_basic_info_32() {
    assert_eq!(::std::mem::size_of::<task_basic_info_32>(),
               32usize,
               concat!("Size of: ", stringify!(task_basic_info_32)));
    assert_eq!(::std::mem::align_of::<task_basic_info_32>(),
               4usize,
               concat!("Alignment of ", stringify!(task_basic_info_32)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info_32)).suspend_count as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info_32),
                       "::",
                       stringify!(suspend_count)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info_32)).virtual_size as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info_32),
                       "::",
                       stringify!(virtual_size)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info_32)).resident_size as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info_32),
                       "::",
                       stringify!(resident_size)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info_32)).user_time as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info_32),
                       "::",
                       stringify!(user_time)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info_32)).system_time as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info_32),
                       "::",
                       stringify!(system_time)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info_32)).policy as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info_32),
                       "::",
                       stringify!(policy)));
}
impl Clone for task_basic_info_32 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_basic_info_32_data_t = task_basic_info_32;
pub type task_basic_info_32_t = *mut task_basic_info_32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_basic_info_64 {
    pub suspend_count: integer_t,
    pub virtual_size: mach_vm_size_t,
    pub resident_size: mach_vm_size_t,
    pub user_time: time_value_t,
    pub system_time: time_value_t,
    pub policy: policy_t,
}
#[test]
fn bindgen_test_layout_task_basic_info_64() {
    assert_eq!(::std::mem::size_of::<task_basic_info_64>(),
               40usize,
               concat!("Size of: ", stringify!(task_basic_info_64)));
    assert_eq!(::std::mem::align_of::<task_basic_info_64>(),
               4usize,
               concat!("Alignment of ", stringify!(task_basic_info_64)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info_64)).suspend_count as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info_64),
                       "::",
                       stringify!(suspend_count)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info_64)).virtual_size as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info_64),
                       "::",
                       stringify!(virtual_size)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info_64)).resident_size as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info_64),
                       "::",
                       stringify!(resident_size)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info_64)).user_time as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info_64),
                       "::",
                       stringify!(user_time)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info_64)).system_time as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info_64),
                       "::",
                       stringify!(system_time)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info_64)).policy as *const _ as usize },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info_64),
                       "::",
                       stringify!(policy)));
}
impl Clone for task_basic_info_64 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_basic_info_64_data_t = task_basic_info_64;
pub type task_basic_info_64_t = *mut task_basic_info_64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_basic_info {
    pub suspend_count: integer_t,
    pub virtual_size: vm_size_t,
    pub resident_size: vm_size_t,
    pub user_time: time_value_t,
    pub system_time: time_value_t,
    pub policy: policy_t,
}
#[test]
fn bindgen_test_layout_task_basic_info() {
    assert_eq!(::std::mem::size_of::<task_basic_info>(),
               40usize,
               concat!("Size of: ", stringify!(task_basic_info)));
    assert_eq!(::std::mem::align_of::<task_basic_info>(),
               4usize,
               concat!("Alignment of ", stringify!(task_basic_info)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info)).suspend_count as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info),
                       "::",
                       stringify!(suspend_count)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info)).virtual_size as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info),
                       "::",
                       stringify!(virtual_size)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info)).resident_size as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info),
                       "::",
                       stringify!(resident_size)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info)).user_time as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info),
                       "::",
                       stringify!(user_time)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info)).system_time as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info),
                       "::",
                       stringify!(system_time)));
    assert_eq!(unsafe { &(*(0 as *const task_basic_info)).policy as *const _ as usize },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(task_basic_info),
                       "::",
                       stringify!(policy)));
}
impl Clone for task_basic_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_basic_info_data_t = task_basic_info;
pub type task_basic_info_t = *mut task_basic_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_events_info {
    pub faults: integer_t,
    pub pageins: integer_t,
    pub cow_faults: integer_t,
    pub messages_sent: integer_t,
    pub messages_received: integer_t,
    pub syscalls_mach: integer_t,
    pub syscalls_unix: integer_t,
    pub csw: integer_t,
}
#[test]
fn bindgen_test_layout_task_events_info() {
    assert_eq!(::std::mem::size_of::<task_events_info>(),
               32usize,
               concat!("Size of: ", stringify!(task_events_info)));
    assert_eq!(::std::mem::align_of::<task_events_info>(),
               4usize,
               concat!("Alignment of ", stringify!(task_events_info)));
    assert_eq!(unsafe { &(*(0 as *const task_events_info)).faults as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_events_info),
                       "::",
                       stringify!(faults)));
    assert_eq!(unsafe { &(*(0 as *const task_events_info)).pageins as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(task_events_info),
                       "::",
                       stringify!(pageins)));
    assert_eq!(unsafe { &(*(0 as *const task_events_info)).cow_faults as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(task_events_info),
                       "::",
                       stringify!(cow_faults)));
    assert_eq!(unsafe { &(*(0 as *const task_events_info)).messages_sent as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(task_events_info),
                       "::",
                       stringify!(messages_sent)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_events_info)).messages_received as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(task_events_info),
                       "::",
                       stringify!(messages_received)));
    assert_eq!(unsafe { &(*(0 as *const task_events_info)).syscalls_mach as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(task_events_info),
                       "::",
                       stringify!(syscalls_mach)));
    assert_eq!(unsafe { &(*(0 as *const task_events_info)).syscalls_unix as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(task_events_info),
                       "::",
                       stringify!(syscalls_unix)));
    assert_eq!(unsafe { &(*(0 as *const task_events_info)).csw as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(task_events_info),
                       "::",
                       stringify!(csw)));
}
impl Clone for task_events_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_events_info_data_t = task_events_info;
pub type task_events_info_t = *mut task_events_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_thread_times_info {
    pub user_time: time_value_t,
    pub system_time: time_value_t,
}
#[test]
fn bindgen_test_layout_task_thread_times_info() {
    assert_eq!(::std::mem::size_of::<task_thread_times_info>(),
               16usize,
               concat!("Size of: ", stringify!(task_thread_times_info)));
    assert_eq!(::std::mem::align_of::<task_thread_times_info>(),
               4usize,
               concat!("Alignment of ", stringify!(task_thread_times_info)));
    assert_eq!(unsafe { &(*(0 as *const task_thread_times_info)).user_time as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_thread_times_info),
                       "::",
                       stringify!(user_time)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_thread_times_info)).system_time as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(task_thread_times_info),
                       "::",
                       stringify!(system_time)));
}
impl Clone for task_thread_times_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_thread_times_info_data_t = task_thread_times_info;
pub type task_thread_times_info_t = *mut task_thread_times_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_absolutetime_info {
    pub total_user: u64,
    pub total_system: u64,
    pub threads_user: u64,
    pub threads_system: u64,
}
#[test]
fn bindgen_test_layout_task_absolutetime_info() {
    assert_eq!(::std::mem::size_of::<task_absolutetime_info>(),
               32usize,
               concat!("Size of: ", stringify!(task_absolutetime_info)));
    assert_eq!(::std::mem::align_of::<task_absolutetime_info>(),
               4usize,
               concat!("Alignment of ", stringify!(task_absolutetime_info)));
    assert_eq!(unsafe { &(*(0 as *const task_absolutetime_info)).total_user as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_absolutetime_info),
                       "::",
                       stringify!(total_user)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_absolutetime_info)).total_system as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(task_absolutetime_info),
                       "::",
                       stringify!(total_system)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_absolutetime_info)).threads_user as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(task_absolutetime_info),
                       "::",
                       stringify!(threads_user)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_absolutetime_info)).threads_system as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(task_absolutetime_info),
                       "::",
                       stringify!(threads_system)));
}
impl Clone for task_absolutetime_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_absolutetime_info_data_t = task_absolutetime_info;
pub type task_absolutetime_info_t = *mut task_absolutetime_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_kernelmemory_info {
    pub total_palloc: u64,
    pub total_pfree: u64,
    pub total_salloc: u64,
    pub total_sfree: u64,
}
#[test]
fn bindgen_test_layout_task_kernelmemory_info() {
    assert_eq!(::std::mem::size_of::<task_kernelmemory_info>(),
               32usize,
               concat!("Size of: ", stringify!(task_kernelmemory_info)));
    assert_eq!(::std::mem::align_of::<task_kernelmemory_info>(),
               4usize,
               concat!("Alignment of ", stringify!(task_kernelmemory_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_kernelmemory_info)).total_palloc as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_kernelmemory_info),
                       "::",
                       stringify!(total_palloc)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_kernelmemory_info)).total_pfree as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(task_kernelmemory_info),
                       "::",
                       stringify!(total_pfree)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_kernelmemory_info)).total_salloc as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(task_kernelmemory_info),
                       "::",
                       stringify!(total_salloc)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_kernelmemory_info)).total_sfree as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(task_kernelmemory_info),
                       "::",
                       stringify!(total_sfree)));
}
impl Clone for task_kernelmemory_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_kernelmemory_info_data_t = task_kernelmemory_info;
pub type task_kernelmemory_info_t = *mut task_kernelmemory_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_affinity_tag_info {
    pub set_count: integer_t,
    pub min: integer_t,
    pub max: integer_t,
    pub task_count: integer_t,
}
#[test]
fn bindgen_test_layout_task_affinity_tag_info() {
    assert_eq!(::std::mem::size_of::<task_affinity_tag_info>(),
               16usize,
               concat!("Size of: ", stringify!(task_affinity_tag_info)));
    assert_eq!(::std::mem::align_of::<task_affinity_tag_info>(),
               4usize,
               concat!("Alignment of ", stringify!(task_affinity_tag_info)));
    assert_eq!(unsafe { &(*(0 as *const task_affinity_tag_info)).set_count as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_affinity_tag_info),
                       "::",
                       stringify!(set_count)));
    assert_eq!(unsafe { &(*(0 as *const task_affinity_tag_info)).min as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(task_affinity_tag_info),
                       "::",
                       stringify!(min)));
    assert_eq!(unsafe { &(*(0 as *const task_affinity_tag_info)).max as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(task_affinity_tag_info),
                       "::",
                       stringify!(max)));
    assert_eq!(unsafe { &(*(0 as *const task_affinity_tag_info)).task_count as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(task_affinity_tag_info),
                       "::",
                       stringify!(task_count)));
}
impl Clone for task_affinity_tag_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_affinity_tag_info_data_t = task_affinity_tag_info;
pub type task_affinity_tag_info_t = *mut task_affinity_tag_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_dyld_info {
    pub all_image_info_addr: mach_vm_address_t,
    pub all_image_info_size: mach_vm_size_t,
    pub all_image_info_format: integer_t,
}
#[test]
fn bindgen_test_layout_task_dyld_info() {
    assert_eq!(::std::mem::size_of::<task_dyld_info>(),
               20usize,
               concat!("Size of: ", stringify!(task_dyld_info)));
    assert_eq!(::std::mem::align_of::<task_dyld_info>(),
               4usize,
               concat!("Alignment of ", stringify!(task_dyld_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_dyld_info)).all_image_info_addr as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_dyld_info),
                       "::",
                       stringify!(all_image_info_addr)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_dyld_info)).all_image_info_size as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(task_dyld_info),
                       "::",
                       stringify!(all_image_info_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_dyld_info)).all_image_info_format as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(task_dyld_info),
                       "::",
                       stringify!(all_image_info_format)));
}
impl Clone for task_dyld_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_dyld_info_data_t = task_dyld_info;
pub type task_dyld_info_t = *mut task_dyld_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_extmod_info {
    pub task_uuid: [::std::os::raw::c_uchar; 16usize],
    pub extmod_statistics: vm_extmod_statistics_data_t,
}
#[test]
fn bindgen_test_layout_task_extmod_info() {
    assert_eq!(::std::mem::size_of::<task_extmod_info>(),
               64usize,
               concat!("Size of: ", stringify!(task_extmod_info)));
    assert_eq!(::std::mem::align_of::<task_extmod_info>(),
               4usize,
               concat!("Alignment of ", stringify!(task_extmod_info)));
    assert_eq!(unsafe { &(*(0 as *const task_extmod_info)).task_uuid as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_extmod_info),
                       "::",
                       stringify!(task_uuid)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_extmod_info)).extmod_statistics as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(task_extmod_info),
                       "::",
                       stringify!(extmod_statistics)));
}
impl Clone for task_extmod_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_extmod_info_data_t = task_extmod_info;
pub type task_extmod_info_t = *mut task_extmod_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_task_basic_info {
    pub virtual_size: mach_vm_size_t,
    pub resident_size: mach_vm_size_t,
    pub resident_size_max: mach_vm_size_t,
    pub user_time: time_value_t,
    pub system_time: time_value_t,
    pub policy: policy_t,
    pub suspend_count: integer_t,
}
#[test]
fn bindgen_test_layout_mach_task_basic_info() {
    assert_eq!(::std::mem::size_of::<mach_task_basic_info>(),
               48usize,
               concat!("Size of: ", stringify!(mach_task_basic_info)));
    assert_eq!(::std::mem::align_of::<mach_task_basic_info>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_task_basic_info)));
    assert_eq!(unsafe { &(*(0 as *const mach_task_basic_info)).virtual_size as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_task_basic_info),
                       "::",
                       stringify!(virtual_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_task_basic_info)).resident_size as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(mach_task_basic_info),
                       "::",
                       stringify!(resident_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_task_basic_info)).resident_size_max as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(mach_task_basic_info),
                       "::",
                       stringify!(resident_size_max)));
    assert_eq!(unsafe { &(*(0 as *const mach_task_basic_info)).user_time as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(mach_task_basic_info),
                       "::",
                       stringify!(user_time)));
    assert_eq!(unsafe { &(*(0 as *const mach_task_basic_info)).system_time as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(mach_task_basic_info),
                       "::",
                       stringify!(system_time)));
    assert_eq!(unsafe { &(*(0 as *const mach_task_basic_info)).policy as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(mach_task_basic_info),
                       "::",
                       stringify!(policy)));
    assert_eq!(unsafe {
                   &(*(0 as *const mach_task_basic_info)).suspend_count as *const _ as usize
               },
               44usize,
               concat!("Alignment of field: ",
                       stringify!(mach_task_basic_info),
                       "::",
                       stringify!(suspend_count)));
}
impl Clone for mach_task_basic_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type mach_task_basic_info_data_t = mach_task_basic_info;
pub type mach_task_basic_info_t = *mut mach_task_basic_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_power_info {
    pub total_user: u64,
    pub total_system: u64,
    pub task_interrupt_wakeups: u64,
    pub task_platform_idle_wakeups: u64,
    pub task_timer_wakeups_bin_1: u64,
    pub task_timer_wakeups_bin_2: u64,
}
#[test]
fn bindgen_test_layout_task_power_info() {
    assert_eq!(::std::mem::size_of::<task_power_info>(),
               48usize,
               concat!("Size of: ", stringify!(task_power_info)));
    assert_eq!(::std::mem::align_of::<task_power_info>(),
               4usize,
               concat!("Alignment of ", stringify!(task_power_info)));
    assert_eq!(unsafe { &(*(0 as *const task_power_info)).total_user as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_power_info),
                       "::",
                       stringify!(total_user)));
    assert_eq!(unsafe { &(*(0 as *const task_power_info)).total_system as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(task_power_info),
                       "::",
                       stringify!(total_system)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_power_info)).task_interrupt_wakeups as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(task_power_info),
                       "::",
                       stringify!(task_interrupt_wakeups)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_power_info)).task_platform_idle_wakeups as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(task_power_info),
                       "::",
                       stringify!(task_platform_idle_wakeups)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_power_info)).task_timer_wakeups_bin_1 as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(task_power_info),
                       "::",
                       stringify!(task_timer_wakeups_bin_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_power_info)).task_timer_wakeups_bin_2 as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(task_power_info),
                       "::",
                       stringify!(task_timer_wakeups_bin_2)));
}
impl Clone for task_power_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_power_info_data_t = task_power_info;
pub type task_power_info_t = *mut task_power_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_vm_info {
    pub virtual_size: mach_vm_size_t,
    pub region_count: integer_t,
    pub page_size: integer_t,
    pub resident_size: mach_vm_size_t,
    pub resident_size_peak: mach_vm_size_t,
    pub device: mach_vm_size_t,
    pub device_peak: mach_vm_size_t,
    pub internal: mach_vm_size_t,
    pub internal_peak: mach_vm_size_t,
    pub external: mach_vm_size_t,
    pub external_peak: mach_vm_size_t,
    pub reusable: mach_vm_size_t,
    pub reusable_peak: mach_vm_size_t,
    pub purgeable_volatile_pmap: mach_vm_size_t,
    pub purgeable_volatile_resident: mach_vm_size_t,
    pub purgeable_volatile_virtual: mach_vm_size_t,
    pub compressed: mach_vm_size_t,
    pub compressed_peak: mach_vm_size_t,
    pub compressed_lifetime: mach_vm_size_t,
    pub phys_footprint: mach_vm_size_t,
    pub min_address: mach_vm_address_t,
    pub max_address: mach_vm_address_t,
}
#[test]
fn bindgen_test_layout_task_vm_info() {
    assert_eq!(::std::mem::size_of::<task_vm_info>(),
               168usize,
               concat!("Size of: ", stringify!(task_vm_info)));
    assert_eq!(::std::mem::align_of::<task_vm_info>(),
               4usize,
               concat!("Alignment of ", stringify!(task_vm_info)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).virtual_size as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(virtual_size)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).region_count as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(region_count)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).page_size as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(page_size)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).resident_size as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(resident_size)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).resident_size_peak as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(resident_size_peak)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).device as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(device)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).device_peak as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(device_peak)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).internal as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(internal)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).internal_peak as *const _ as usize },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(internal_peak)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).external as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(external)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).external_peak as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(external_peak)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).reusable as *const _ as usize },
               80usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(reusable)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).reusable_peak as *const _ as usize },
               88usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(reusable_peak)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_vm_info)).purgeable_volatile_pmap as *const _ as usize
               },
               96usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(purgeable_volatile_pmap)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_vm_info)).purgeable_volatile_resident as *const _ as usize
               },
               104usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(purgeable_volatile_resident)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_vm_info)).purgeable_volatile_virtual as *const _ as usize
               },
               112usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(purgeable_volatile_virtual)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).compressed as *const _ as usize },
               120usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(compressed)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).compressed_peak as *const _ as usize },
               128usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(compressed_peak)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).compressed_lifetime as *const _ as usize },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(compressed_lifetime)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).phys_footprint as *const _ as usize },
               144usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(phys_footprint)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).min_address as *const _ as usize },
               152usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(min_address)));
    assert_eq!(unsafe { &(*(0 as *const task_vm_info)).max_address as *const _ as usize },
               160usize,
               concat!("Alignment of field: ",
                       stringify!(task_vm_info),
                       "::",
                       stringify!(max_address)));
}
impl Clone for task_vm_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_vm_info_data_t = task_vm_info;
pub type task_vm_info_t = *mut task_vm_info;
pub type task_purgable_info_t = vm_purgeable_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_trace_memory_info {
    pub user_memory_address: u64,
    pub buffer_size: u64,
    pub mailbox_array_size: u64,
}
#[test]
fn bindgen_test_layout_task_trace_memory_info() {
    assert_eq!(::std::mem::size_of::<task_trace_memory_info>(),
               24usize,
               concat!("Size of: ", stringify!(task_trace_memory_info)));
    assert_eq!(::std::mem::align_of::<task_trace_memory_info>(),
               4usize,
               concat!("Alignment of ", stringify!(task_trace_memory_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_trace_memory_info)).user_memory_address as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_trace_memory_info),
                       "::",
                       stringify!(user_memory_address)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_trace_memory_info)).buffer_size as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(task_trace_memory_info),
                       "::",
                       stringify!(buffer_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_trace_memory_info)).mailbox_array_size as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(task_trace_memory_info),
                       "::",
                       stringify!(mailbox_array_size)));
}
impl Clone for task_trace_memory_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_trace_memory_info_data_t = task_trace_memory_info;
pub type task_trace_memory_info_t = *mut task_trace_memory_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_wait_state_info {
    pub total_wait_state_time: u64,
    pub total_wait_sfi_state_time: u64,
    pub _reserved: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_task_wait_state_info() {
    assert_eq!(::std::mem::size_of::<task_wait_state_info>(),
               32usize,
               concat!("Size of: ", stringify!(task_wait_state_info)));
    assert_eq!(::std::mem::align_of::<task_wait_state_info>(),
               4usize,
               concat!("Alignment of ", stringify!(task_wait_state_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_wait_state_info)).total_wait_state_time as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_wait_state_info),
                       "::",
                       stringify!(total_wait_state_time)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_wait_state_info)).total_wait_sfi_state_time as *const _ as
                   usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(task_wait_state_info),
                       "::",
                       stringify!(total_wait_sfi_state_time)));
    assert_eq!(unsafe { &(*(0 as *const task_wait_state_info))._reserved as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(task_wait_state_info),
                       "::",
                       stringify!(_reserved)));
}
impl Clone for task_wait_state_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_wait_state_info_data_t = task_wait_state_info;
pub type task_wait_state_info_t = *mut task_wait_state_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gpu_energy_data {
    pub task_gpu_utilisation: u64,
    pub task_gpu_stat_reserved0: u64,
    pub task_gpu_stat_reserved1: u64,
    pub task_gpu_stat_reserved2: u64,
}
#[test]
fn bindgen_test_layout_gpu_energy_data() {
    assert_eq!(::std::mem::size_of::<gpu_energy_data>(),
               32usize,
               concat!("Size of: ", stringify!(gpu_energy_data)));
    assert_eq!(::std::mem::align_of::<gpu_energy_data>(),
               4usize,
               concat!("Alignment of ", stringify!(gpu_energy_data)));
    assert_eq!(unsafe {
                   &(*(0 as *const gpu_energy_data)).task_gpu_utilisation as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(gpu_energy_data),
                       "::",
                       stringify!(task_gpu_utilisation)));
    assert_eq!(unsafe {
                   &(*(0 as *const gpu_energy_data)).task_gpu_stat_reserved0 as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(gpu_energy_data),
                       "::",
                       stringify!(task_gpu_stat_reserved0)));
    assert_eq!(unsafe {
                   &(*(0 as *const gpu_energy_data)).task_gpu_stat_reserved1 as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(gpu_energy_data),
                       "::",
                       stringify!(task_gpu_stat_reserved1)));
    assert_eq!(unsafe {
                   &(*(0 as *const gpu_energy_data)).task_gpu_stat_reserved2 as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(gpu_energy_data),
                       "::",
                       stringify!(task_gpu_stat_reserved2)));
}
impl Clone for gpu_energy_data {
    fn clone(&self) -> Self {
        *self
    }
}
pub type gpu_energy_data_t = *mut gpu_energy_data;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_power_info_v2 {
    pub cpu_energy: task_power_info_data_t,
    pub gpu_energy: gpu_energy_data,
    pub task_ptime: u64,
    pub task_pset_switches: u64,
}
#[test]
fn bindgen_test_layout_task_power_info_v2() {
    assert_eq!(::std::mem::size_of::<task_power_info_v2>(),
               96usize,
               concat!("Size of: ", stringify!(task_power_info_v2)));
    assert_eq!(::std::mem::align_of::<task_power_info_v2>(),
               4usize,
               concat!("Alignment of ", stringify!(task_power_info_v2)));
    assert_eq!(unsafe { &(*(0 as *const task_power_info_v2)).cpu_energy as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_power_info_v2),
                       "::",
                       stringify!(cpu_energy)));
    assert_eq!(unsafe { &(*(0 as *const task_power_info_v2)).gpu_energy as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(task_power_info_v2),
                       "::",
                       stringify!(gpu_energy)));
    assert_eq!(unsafe { &(*(0 as *const task_power_info_v2)).task_ptime as *const _ as usize },
               80usize,
               concat!("Alignment of field: ",
                       stringify!(task_power_info_v2),
                       "::",
                       stringify!(task_ptime)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_power_info_v2)).task_pset_switches as *const _ as usize
               },
               88usize,
               concat!("Alignment of field: ",
                       stringify!(task_power_info_v2),
                       "::",
                       stringify!(task_pset_switches)));
}
impl Clone for task_power_info_v2 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_power_info_v2_data_t = task_power_info_v2;
pub type task_power_info_v2_t = *mut task_power_info_v2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_flags_info {
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_task_flags_info() {
    assert_eq!(::std::mem::size_of::<task_flags_info>(),
               4usize,
               concat!("Size of: ", stringify!(task_flags_info)));
    assert_eq!(::std::mem::align_of::<task_flags_info>(),
               4usize,
               concat!("Alignment of ", stringify!(task_flags_info)));
    assert_eq!(unsafe { &(*(0 as *const task_flags_info)).flags as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_flags_info),
                       "::",
                       stringify!(flags)));
}
impl Clone for task_flags_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_flags_info_data_t = task_flags_info;
pub type task_flags_info_t = *mut task_flags_info;
pub type task_inspect_flavor_t = natural_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum task_inspect_flavor {
    TASK_INSPECT_BASIC_COUNTS = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_inspect_basic_counts {
    pub instructions: u64,
    pub cycles: u64,
}
#[test]
fn bindgen_test_layout_task_inspect_basic_counts() {
    assert_eq!(::std::mem::size_of::<task_inspect_basic_counts>(),
               16usize,
               concat!("Size of: ", stringify!(task_inspect_basic_counts)));
    assert_eq!(::std::mem::align_of::<task_inspect_basic_counts>(),
               8usize,
               concat!("Alignment of ", stringify!(task_inspect_basic_counts)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_inspect_basic_counts)).instructions as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_inspect_basic_counts),
                       "::",
                       stringify!(instructions)));
    assert_eq!(unsafe { &(*(0 as *const task_inspect_basic_counts)).cycles as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(task_inspect_basic_counts),
                       "::",
                       stringify!(cycles)));
}
impl Clone for task_inspect_basic_counts {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_inspect_basic_counts_data_t = task_inspect_basic_counts;
pub type task_inspect_basic_counts_t = *mut task_inspect_basic_counts;
pub type task_inspect_info_t = *mut integer_t;
pub type task_policy_flavor_t = natural_t;
pub type task_policy_t = *mut integer_t;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum task_role {
    TASK_RENICED = -1,
    TASK_UNSPECIFIED = 0,
    TASK_FOREGROUND_APPLICATION = 1,
    TASK_BACKGROUND_APPLICATION = 2,
    TASK_CONTROL_APPLICATION = 3,
    TASK_GRAPHICS_SERVER = 4,
    TASK_THROTTLE_APPLICATION = 5,
    TASK_NONUI_APPLICATION = 6,
    TASK_DEFAULT_APPLICATION = 7,
}
pub type task_role_t = integer_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_category_policy {
    pub role: task_role_t,
}
#[test]
fn bindgen_test_layout_task_category_policy() {
    assert_eq!(::std::mem::size_of::<task_category_policy>(),
               4usize,
               concat!("Size of: ", stringify!(task_category_policy)));
    assert_eq!(::std::mem::align_of::<task_category_policy>(),
               4usize,
               concat!("Alignment of ", stringify!(task_category_policy)));
    assert_eq!(unsafe { &(*(0 as *const task_category_policy)).role as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_category_policy),
                       "::",
                       stringify!(role)));
}
impl Clone for task_category_policy {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_category_policy_data_t = task_category_policy;
pub type task_category_policy_t = *mut task_category_policy;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum task_latency_qos {
    LATENCY_QOS_TIER_UNSPECIFIED = 0,
    LATENCY_QOS_TIER_0 = 16711681,
    LATENCY_QOS_TIER_1 = 16711682,
    LATENCY_QOS_TIER_2 = 16711683,
    LATENCY_QOS_TIER_3 = 16711684,
    LATENCY_QOS_TIER_4 = 16711685,
    LATENCY_QOS_TIER_5 = 16711686,
}
pub type task_latency_qos_t = integer_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum task_throughput_qos {
    THROUGHPUT_QOS_TIER_UNSPECIFIED = 0,
    THROUGHPUT_QOS_TIER_0 = 16646145,
    THROUGHPUT_QOS_TIER_1 = 16646146,
    THROUGHPUT_QOS_TIER_2 = 16646147,
    THROUGHPUT_QOS_TIER_3 = 16646148,
    THROUGHPUT_QOS_TIER_4 = 16646149,
    THROUGHPUT_QOS_TIER_5 = 16646150,
}
pub type task_throughput_qos_t = integer_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task_qos_policy {
    pub task_latency_qos_tier: task_latency_qos_t,
    pub task_throughput_qos_tier: task_throughput_qos_t,
}
#[test]
fn bindgen_test_layout_task_qos_policy() {
    assert_eq!(::std::mem::size_of::<task_qos_policy>(),
               8usize,
               concat!("Size of: ", stringify!(task_qos_policy)));
    assert_eq!(::std::mem::align_of::<task_qos_policy>(),
               4usize,
               concat!("Alignment of ", stringify!(task_qos_policy)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_qos_policy)).task_latency_qos_tier as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(task_qos_policy),
                       "::",
                       stringify!(task_latency_qos_tier)));
    assert_eq!(unsafe {
                   &(*(0 as *const task_qos_policy)).task_throughput_qos_tier as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(task_qos_policy),
                       "::",
                       stringify!(task_throughput_qos_tier)));
}
impl Clone for task_qos_policy {
    fn clone(&self) -> Self {
        *self
    }
}
pub type task_qos_policy_t = *mut task_qos_policy;
pub type task_special_port_t = ::std::os::raw::c_int;
pub type thread_flavor_t = natural_t;
pub type thread_info_t = *mut integer_t;
pub type thread_info_data_t = [integer_t; 32usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread_basic_info {
    pub user_time: time_value_t,
    pub system_time: time_value_t,
    pub cpu_usage: integer_t,
    pub policy: policy_t,
    pub run_state: integer_t,
    pub flags: integer_t,
    pub suspend_count: integer_t,
    pub sleep_time: integer_t,
}
#[test]
fn bindgen_test_layout_thread_basic_info() {
    assert_eq!(::std::mem::size_of::<thread_basic_info>(),
               40usize,
               concat!("Size of: ", stringify!(thread_basic_info)));
    assert_eq!(::std::mem::align_of::<thread_basic_info>(),
               4usize,
               concat!("Alignment of ", stringify!(thread_basic_info)));
    assert_eq!(unsafe { &(*(0 as *const thread_basic_info)).user_time as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(thread_basic_info),
                       "::",
                       stringify!(user_time)));
    assert_eq!(unsafe { &(*(0 as *const thread_basic_info)).system_time as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(thread_basic_info),
                       "::",
                       stringify!(system_time)));
    assert_eq!(unsafe { &(*(0 as *const thread_basic_info)).cpu_usage as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(thread_basic_info),
                       "::",
                       stringify!(cpu_usage)));
    assert_eq!(unsafe { &(*(0 as *const thread_basic_info)).policy as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(thread_basic_info),
                       "::",
                       stringify!(policy)));
    assert_eq!(unsafe { &(*(0 as *const thread_basic_info)).run_state as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(thread_basic_info),
                       "::",
                       stringify!(run_state)));
    assert_eq!(unsafe { &(*(0 as *const thread_basic_info)).flags as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(thread_basic_info),
                       "::",
                       stringify!(flags)));
    assert_eq!(unsafe { &(*(0 as *const thread_basic_info)).suspend_count as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(thread_basic_info),
                       "::",
                       stringify!(suspend_count)));
    assert_eq!(unsafe { &(*(0 as *const thread_basic_info)).sleep_time as *const _ as usize },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(thread_basic_info),
                       "::",
                       stringify!(sleep_time)));
}
impl Clone for thread_basic_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type thread_basic_info_data_t = thread_basic_info;
pub type thread_basic_info_t = *mut thread_basic_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread_identifier_info {
    pub thread_id: u64,
    pub thread_handle: u64,
    pub dispatch_qaddr: u64,
}
#[test]
fn bindgen_test_layout_thread_identifier_info() {
    assert_eq!(::std::mem::size_of::<thread_identifier_info>(),
               24usize,
               concat!("Size of: ", stringify!(thread_identifier_info)));
    assert_eq!(::std::mem::align_of::<thread_identifier_info>(),
               8usize,
               concat!("Alignment of ", stringify!(thread_identifier_info)));
    assert_eq!(unsafe { &(*(0 as *const thread_identifier_info)).thread_id as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(thread_identifier_info),
                       "::",
                       stringify!(thread_id)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_identifier_info)).thread_handle as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(thread_identifier_info),
                       "::",
                       stringify!(thread_handle)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_identifier_info)).dispatch_qaddr as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(thread_identifier_info),
                       "::",
                       stringify!(dispatch_qaddr)));
}
impl Clone for thread_identifier_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type thread_identifier_info_data_t = thread_identifier_info;
pub type thread_identifier_info_t = *mut thread_identifier_info;
#[repr(C)]
pub struct thread_extended_info {
    pub pth_user_time: u64,
    pub pth_system_time: u64,
    pub pth_cpu_usage: i32,
    pub pth_policy: i32,
    pub pth_run_state: i32,
    pub pth_flags: i32,
    pub pth_sleep_time: i32,
    pub pth_curpri: i32,
    pub pth_priority: i32,
    pub pth_maxpriority: i32,
    pub pth_name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_thread_extended_info() {
    assert_eq!(::std::mem::size_of::<thread_extended_info>(),
               112usize,
               concat!("Size of: ", stringify!(thread_extended_info)));
    assert_eq!(::std::mem::align_of::<thread_extended_info>(),
               8usize,
               concat!("Alignment of ", stringify!(thread_extended_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_extended_info)).pth_user_time as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(thread_extended_info),
                       "::",
                       stringify!(pth_user_time)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_extended_info)).pth_system_time as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(thread_extended_info),
                       "::",
                       stringify!(pth_system_time)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_extended_info)).pth_cpu_usage as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(thread_extended_info),
                       "::",
                       stringify!(pth_cpu_usage)));
    assert_eq!(unsafe { &(*(0 as *const thread_extended_info)).pth_policy as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(thread_extended_info),
                       "::",
                       stringify!(pth_policy)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_extended_info)).pth_run_state as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(thread_extended_info),
                       "::",
                       stringify!(pth_run_state)));
    assert_eq!(unsafe { &(*(0 as *const thread_extended_info)).pth_flags as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(thread_extended_info),
                       "::",
                       stringify!(pth_flags)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_extended_info)).pth_sleep_time as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(thread_extended_info),
                       "::",
                       stringify!(pth_sleep_time)));
    assert_eq!(unsafe { &(*(0 as *const thread_extended_info)).pth_curpri as *const _ as usize },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(thread_extended_info),
                       "::",
                       stringify!(pth_curpri)));
    assert_eq!(unsafe { &(*(0 as *const thread_extended_info)).pth_priority as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(thread_extended_info),
                       "::",
                       stringify!(pth_priority)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_extended_info)).pth_maxpriority as *const _ as usize
               },
               44usize,
               concat!("Alignment of field: ",
                       stringify!(thread_extended_info),
                       "::",
                       stringify!(pth_maxpriority)));
    assert_eq!(unsafe { &(*(0 as *const thread_extended_info)).pth_name as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(thread_extended_info),
                       "::",
                       stringify!(pth_name)));
}
pub type thread_extended_info_data_t = thread_extended_info;
pub type thread_extended_info_t = *mut thread_extended_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct io_stat_entry {
    pub count: u64,
    pub size: u64,
}
#[test]
fn bindgen_test_layout_io_stat_entry() {
    assert_eq!(::std::mem::size_of::<io_stat_entry>(),
               16usize,
               concat!("Size of: ", stringify!(io_stat_entry)));
    assert_eq!(::std::mem::align_of::<io_stat_entry>(),
               8usize,
               concat!("Alignment of ", stringify!(io_stat_entry)));
    assert_eq!(unsafe { &(*(0 as *const io_stat_entry)).count as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(io_stat_entry),
                       "::",
                       stringify!(count)));
    assert_eq!(unsafe { &(*(0 as *const io_stat_entry)).size as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(io_stat_entry),
                       "::",
                       stringify!(size)));
}
impl Clone for io_stat_entry {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct io_stat_info {
    pub disk_reads: io_stat_entry,
    pub io_priority: [io_stat_entry; 4usize],
    pub paging: io_stat_entry,
    pub metadata: io_stat_entry,
    pub total_io: io_stat_entry,
}
#[test]
fn bindgen_test_layout_io_stat_info() {
    assert_eq!(::std::mem::size_of::<io_stat_info>(),
               128usize,
               concat!("Size of: ", stringify!(io_stat_info)));
    assert_eq!(::std::mem::align_of::<io_stat_info>(),
               8usize,
               concat!("Alignment of ", stringify!(io_stat_info)));
    assert_eq!(unsafe { &(*(0 as *const io_stat_info)).disk_reads as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(io_stat_info),
                       "::",
                       stringify!(disk_reads)));
    assert_eq!(unsafe { &(*(0 as *const io_stat_info)).io_priority as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(io_stat_info),
                       "::",
                       stringify!(io_priority)));
    assert_eq!(unsafe { &(*(0 as *const io_stat_info)).paging as *const _ as usize },
               80usize,
               concat!("Alignment of field: ",
                       stringify!(io_stat_info),
                       "::",
                       stringify!(paging)));
    assert_eq!(unsafe { &(*(0 as *const io_stat_info)).metadata as *const _ as usize },
               96usize,
               concat!("Alignment of field: ",
                       stringify!(io_stat_info),
                       "::",
                       stringify!(metadata)));
    assert_eq!(unsafe { &(*(0 as *const io_stat_info)).total_io as *const _ as usize },
               112usize,
               concat!("Alignment of field: ",
                       stringify!(io_stat_info),
                       "::",
                       stringify!(total_io)));
}
impl Clone for io_stat_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type io_stat_info_t = *mut io_stat_info;
pub type thread_policy_flavor_t = natural_t;
pub type thread_policy_t = *mut integer_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread_standard_policy {
    pub no_data: natural_t,
}
#[test]
fn bindgen_test_layout_thread_standard_policy() {
    assert_eq!(::std::mem::size_of::<thread_standard_policy>(),
               4usize,
               concat!("Size of: ", stringify!(thread_standard_policy)));
    assert_eq!(::std::mem::align_of::<thread_standard_policy>(),
               4usize,
               concat!("Alignment of ", stringify!(thread_standard_policy)));
    assert_eq!(unsafe { &(*(0 as *const thread_standard_policy)).no_data as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(thread_standard_policy),
                       "::",
                       stringify!(no_data)));
}
impl Clone for thread_standard_policy {
    fn clone(&self) -> Self {
        *self
    }
}
pub type thread_standard_policy_data_t = thread_standard_policy;
pub type thread_standard_policy_t = *mut thread_standard_policy;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread_extended_policy {
    pub timeshare: boolean_t,
}
#[test]
fn bindgen_test_layout_thread_extended_policy() {
    assert_eq!(::std::mem::size_of::<thread_extended_policy>(),
               4usize,
               concat!("Size of: ", stringify!(thread_extended_policy)));
    assert_eq!(::std::mem::align_of::<thread_extended_policy>(),
               4usize,
               concat!("Alignment of ", stringify!(thread_extended_policy)));
    assert_eq!(unsafe { &(*(0 as *const thread_extended_policy)).timeshare as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(thread_extended_policy),
                       "::",
                       stringify!(timeshare)));
}
impl Clone for thread_extended_policy {
    fn clone(&self) -> Self {
        *self
    }
}
pub type thread_extended_policy_data_t = thread_extended_policy;
pub type thread_extended_policy_t = *mut thread_extended_policy;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread_time_constraint_policy {
    pub period: u32,
    pub computation: u32,
    pub constraint: u32,
    pub preemptible: boolean_t,
}
#[test]
fn bindgen_test_layout_thread_time_constraint_policy() {
    assert_eq!(::std::mem::size_of::<thread_time_constraint_policy>(),
               16usize,
               concat!("Size of: ", stringify!(thread_time_constraint_policy)));
    assert_eq!(::std::mem::align_of::<thread_time_constraint_policy>(),
               4usize,
               concat!("Alignment of ", stringify!(thread_time_constraint_policy)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_time_constraint_policy)).period as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(thread_time_constraint_policy),
                       "::",
                       stringify!(period)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_time_constraint_policy)).computation as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(thread_time_constraint_policy),
                       "::",
                       stringify!(computation)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_time_constraint_policy)).constraint as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(thread_time_constraint_policy),
                       "::",
                       stringify!(constraint)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_time_constraint_policy)).preemptible as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(thread_time_constraint_policy),
                       "::",
                       stringify!(preemptible)));
}
impl Clone for thread_time_constraint_policy {
    fn clone(&self) -> Self {
        *self
    }
}
pub type thread_time_constraint_policy_data_t = thread_time_constraint_policy;
pub type thread_time_constraint_policy_t = *mut thread_time_constraint_policy;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread_precedence_policy {
    pub importance: integer_t,
}
#[test]
fn bindgen_test_layout_thread_precedence_policy() {
    assert_eq!(::std::mem::size_of::<thread_precedence_policy>(),
               4usize,
               concat!("Size of: ", stringify!(thread_precedence_policy)));
    assert_eq!(::std::mem::align_of::<thread_precedence_policy>(),
               4usize,
               concat!("Alignment of ", stringify!(thread_precedence_policy)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_precedence_policy)).importance as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(thread_precedence_policy),
                       "::",
                       stringify!(importance)));
}
impl Clone for thread_precedence_policy {
    fn clone(&self) -> Self {
        *self
    }
}
pub type thread_precedence_policy_data_t = thread_precedence_policy;
pub type thread_precedence_policy_t = *mut thread_precedence_policy;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread_affinity_policy {
    pub affinity_tag: integer_t,
}
#[test]
fn bindgen_test_layout_thread_affinity_policy() {
    assert_eq!(::std::mem::size_of::<thread_affinity_policy>(),
               4usize,
               concat!("Size of: ", stringify!(thread_affinity_policy)));
    assert_eq!(::std::mem::align_of::<thread_affinity_policy>(),
               4usize,
               concat!("Alignment of ", stringify!(thread_affinity_policy)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_affinity_policy)).affinity_tag as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(thread_affinity_policy),
                       "::",
                       stringify!(affinity_tag)));
}
impl Clone for thread_affinity_policy {
    fn clone(&self) -> Self {
        *self
    }
}
pub type thread_affinity_policy_data_t = thread_affinity_policy;
pub type thread_affinity_policy_t = *mut thread_affinity_policy;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread_background_policy {
    pub priority: integer_t,
}
#[test]
fn bindgen_test_layout_thread_background_policy() {
    assert_eq!(::std::mem::size_of::<thread_background_policy>(),
               4usize,
               concat!("Size of: ", stringify!(thread_background_policy)));
    assert_eq!(::std::mem::align_of::<thread_background_policy>(),
               4usize,
               concat!("Alignment of ", stringify!(thread_background_policy)));
    assert_eq!(unsafe { &(*(0 as *const thread_background_policy)).priority as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(thread_background_policy),
                       "::",
                       stringify!(priority)));
}
impl Clone for thread_background_policy {
    fn clone(&self) -> Self {
        *self
    }
}
pub type thread_background_policy_data_t = thread_background_policy;
pub type thread_background_policy_t = *mut thread_background_policy;
pub type thread_latency_qos_t = integer_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread_latency_qos_policy {
    pub thread_latency_qos_tier: thread_latency_qos_t,
}
#[test]
fn bindgen_test_layout_thread_latency_qos_policy() {
    assert_eq!(::std::mem::size_of::<thread_latency_qos_policy>(),
               4usize,
               concat!("Size of: ", stringify!(thread_latency_qos_policy)));
    assert_eq!(::std::mem::align_of::<thread_latency_qos_policy>(),
               4usize,
               concat!("Alignment of ", stringify!(thread_latency_qos_policy)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_latency_qos_policy)).thread_latency_qos_tier as
                   *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(thread_latency_qos_policy),
                       "::",
                       stringify!(thread_latency_qos_tier)));
}
impl Clone for thread_latency_qos_policy {
    fn clone(&self) -> Self {
        *self
    }
}
pub type thread_latency_qos_policy_data_t = thread_latency_qos_policy;
pub type thread_latency_qos_policy_t = *mut thread_latency_qos_policy;
pub type thread_throughput_qos_t = integer_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread_throughput_qos_policy {
    pub thread_throughput_qos_tier: thread_throughput_qos_t,
}
#[test]
fn bindgen_test_layout_thread_throughput_qos_policy() {
    assert_eq!(::std::mem::size_of::<thread_throughput_qos_policy>(),
               4usize,
               concat!("Size of: ", stringify!(thread_throughput_qos_policy)));
    assert_eq!(::std::mem::align_of::<thread_throughput_qos_policy>(),
               4usize,
               concat!("Alignment of ", stringify!(thread_throughput_qos_policy)));
    assert_eq!(unsafe {
                   &(*(0 as *const thread_throughput_qos_policy)).thread_throughput_qos_tier as
                   *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(thread_throughput_qos_policy),
                       "::",
                       stringify!(thread_throughput_qos_tier)));
}
impl Clone for thread_throughput_qos_policy {
    fn clone(&self) -> Self {
        *self
    }
}
pub type thread_throughput_qos_policy_data_t = thread_throughput_qos_policy;
pub type thread_throughput_qos_policy_t = *mut thread_throughput_qos_policy;
pub type alarm_type_t = ::std::os::raw::c_int;
pub type sleep_type_t = ::std::os::raw::c_int;
pub type clock_id_t = ::std::os::raw::c_int;
pub type clock_flavor_t = ::std::os::raw::c_int;
pub type clock_attr_t = *mut ::std::os::raw::c_int;
pub type clock_res_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_timespec {
    pub tv_sec: ::std::os::raw::c_uint,
    pub tv_nsec: clock_res_t,
}
#[test]
fn bindgen_test_layout_mach_timespec() {
    assert_eq!(::std::mem::size_of::<mach_timespec>(),
               8usize,
               concat!("Size of: ", stringify!(mach_timespec)));
    assert_eq!(::std::mem::align_of::<mach_timespec>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_timespec)));
    assert_eq!(unsafe { &(*(0 as *const mach_timespec)).tv_sec as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_timespec),
                       "::",
                       stringify!(tv_sec)));
    assert_eq!(unsafe { &(*(0 as *const mach_timespec)).tv_nsec as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_timespec),
                       "::",
                       stringify!(tv_nsec)));
}
impl Clone for mach_timespec {
    fn clone(&self) -> Self {
        *self
    }
}
pub type mach_timespec_t = mach_timespec;
pub type vm_machine_attribute_t = ::std::os::raw::c_uint;
pub type vm_machine_attribute_val_t = ::std::os::raw::c_int;
pub type vm_inherit_t = ::std::os::raw::c_uint;
pub type vm_purgable_t = ::std::os::raw::c_int;
pub type vm_behavior_t = ::std::os::raw::c_int;
pub type vm32_object_id_t = u32;
pub type vm_region_info_t = *mut ::std::os::raw::c_int;
pub type vm_region_info_64_t = *mut ::std::os::raw::c_int;
pub type vm_region_recurse_info_t = *mut ::std::os::raw::c_int;
pub type vm_region_recurse_info_64_t = *mut ::std::os::raw::c_int;
pub type vm_region_flavor_t = ::std::os::raw::c_int;
pub type vm_region_info_data_t = [::std::os::raw::c_int; 1024usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_region_basic_info_64 {
    pub protection: vm_prot_t,
    pub max_protection: vm_prot_t,
    pub inheritance: vm_inherit_t,
    pub shared: boolean_t,
    pub reserved: boolean_t,
    pub offset: memory_object_offset_t,
    pub behavior: vm_behavior_t,
    pub user_wired_count: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_vm_region_basic_info_64() {
    assert_eq!(::std::mem::size_of::<vm_region_basic_info_64>(),
               36usize,
               concat!("Size of: ", stringify!(vm_region_basic_info_64)));
    assert_eq!(::std::mem::align_of::<vm_region_basic_info_64>(),
               4usize,
               concat!("Alignment of ", stringify!(vm_region_basic_info_64)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_basic_info_64)).protection as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info_64),
                       "::",
                       stringify!(protection)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_basic_info_64)).max_protection as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info_64),
                       "::",
                       stringify!(max_protection)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_basic_info_64)).inheritance as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info_64),
                       "::",
                       stringify!(inheritance)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_basic_info_64)).shared as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info_64),
                       "::",
                       stringify!(shared)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_basic_info_64)).reserved as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info_64),
                       "::",
                       stringify!(reserved)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_basic_info_64)).offset as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info_64),
                       "::",
                       stringify!(offset)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_basic_info_64)).behavior as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info_64),
                       "::",
                       stringify!(behavior)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_basic_info_64)).user_wired_count as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info_64),
                       "::",
                       stringify!(user_wired_count)));
}
impl Clone for vm_region_basic_info_64 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type vm_region_basic_info_64_t = *mut vm_region_basic_info_64;
pub type vm_region_basic_info_data_64_t = vm_region_basic_info_64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_region_basic_info {
    pub protection: vm_prot_t,
    pub max_protection: vm_prot_t,
    pub inheritance: vm_inherit_t,
    pub shared: boolean_t,
    pub reserved: boolean_t,
    pub offset: u32,
    pub behavior: vm_behavior_t,
    pub user_wired_count: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_vm_region_basic_info() {
    assert_eq!(::std::mem::size_of::<vm_region_basic_info>(),
               32usize,
               concat!("Size of: ", stringify!(vm_region_basic_info)));
    assert_eq!(::std::mem::align_of::<vm_region_basic_info>(),
               4usize,
               concat!("Alignment of ", stringify!(vm_region_basic_info)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_basic_info)).protection as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info),
                       "::",
                       stringify!(protection)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_basic_info)).max_protection as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info),
                       "::",
                       stringify!(max_protection)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_basic_info)).inheritance as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info),
                       "::",
                       stringify!(inheritance)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_basic_info)).shared as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info),
                       "::",
                       stringify!(shared)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_basic_info)).reserved as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info),
                       "::",
                       stringify!(reserved)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_basic_info)).offset as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info),
                       "::",
                       stringify!(offset)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_basic_info)).behavior as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info),
                       "::",
                       stringify!(behavior)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_basic_info)).user_wired_count as *const _ as usize
               },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_basic_info),
                       "::",
                       stringify!(user_wired_count)));
}
impl Clone for vm_region_basic_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type vm_region_basic_info_t = *mut vm_region_basic_info;
pub type vm_region_basic_info_data_t = vm_region_basic_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_region_extended_info {
    pub protection: vm_prot_t,
    pub user_tag: ::std::os::raw::c_uint,
    pub pages_resident: ::std::os::raw::c_uint,
    pub pages_shared_now_private: ::std::os::raw::c_uint,
    pub pages_swapped_out: ::std::os::raw::c_uint,
    pub pages_dirtied: ::std::os::raw::c_uint,
    pub ref_count: ::std::os::raw::c_uint,
    pub shadow_depth: ::std::os::raw::c_ushort,
    pub external_pager: ::std::os::raw::c_uchar,
    pub share_mode: ::std::os::raw::c_uchar,
    pub pages_reusable: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vm_region_extended_info() {
    assert_eq!(::std::mem::size_of::<vm_region_extended_info>(),
               36usize,
               concat!("Size of: ", stringify!(vm_region_extended_info)));
    assert_eq!(::std::mem::align_of::<vm_region_extended_info>(),
               4usize,
               concat!("Alignment of ", stringify!(vm_region_extended_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_extended_info)).protection as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_extended_info),
                       "::",
                       stringify!(protection)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_extended_info)).user_tag as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_extended_info),
                       "::",
                       stringify!(user_tag)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_extended_info)).pages_resident as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_extended_info),
                       "::",
                       stringify!(pages_resident)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_extended_info)).pages_shared_now_private as
                   *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_extended_info),
                       "::",
                       stringify!(pages_shared_now_private)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_extended_info)).pages_swapped_out as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_extended_info),
                       "::",
                       stringify!(pages_swapped_out)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_extended_info)).pages_dirtied as *const _ as usize
               },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_extended_info),
                       "::",
                       stringify!(pages_dirtied)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_extended_info)).ref_count as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_extended_info),
                       "::",
                       stringify!(ref_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_extended_info)).shadow_depth as *const _ as usize
               },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_extended_info),
                       "::",
                       stringify!(shadow_depth)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_extended_info)).external_pager as *const _ as usize
               },
               30usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_extended_info),
                       "::",
                       stringify!(external_pager)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_extended_info)).share_mode as *const _ as usize
               },
               31usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_extended_info),
                       "::",
                       stringify!(share_mode)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_extended_info)).pages_reusable as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_extended_info),
                       "::",
                       stringify!(pages_reusable)));
}
impl Clone for vm_region_extended_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type vm_region_extended_info_t = *mut vm_region_extended_info;
pub type vm_region_extended_info_data_t = vm_region_extended_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_region_top_info {
    pub obj_id: ::std::os::raw::c_uint,
    pub ref_count: ::std::os::raw::c_uint,
    pub private_pages_resident: ::std::os::raw::c_uint,
    pub shared_pages_resident: ::std::os::raw::c_uint,
    pub share_mode: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_vm_region_top_info() {
    assert_eq!(::std::mem::size_of::<vm_region_top_info>(),
               20usize,
               concat!("Size of: ", stringify!(vm_region_top_info)));
    assert_eq!(::std::mem::align_of::<vm_region_top_info>(),
               4usize,
               concat!("Alignment of ", stringify!(vm_region_top_info)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_top_info)).obj_id as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_top_info),
                       "::",
                       stringify!(obj_id)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_top_info)).ref_count as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_top_info),
                       "::",
                       stringify!(ref_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_top_info)).private_pages_resident as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_top_info),
                       "::",
                       stringify!(private_pages_resident)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_top_info)).shared_pages_resident as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_top_info),
                       "::",
                       stringify!(shared_pages_resident)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_top_info)).share_mode as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_top_info),
                       "::",
                       stringify!(share_mode)));
}
impl Clone for vm_region_top_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type vm_region_top_info_t = *mut vm_region_top_info;
pub type vm_region_top_info_data_t = vm_region_top_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_region_submap_info {
    pub protection: vm_prot_t,
    pub max_protection: vm_prot_t,
    pub inheritance: vm_inherit_t,
    pub offset: u32,
    pub user_tag: ::std::os::raw::c_uint,
    pub pages_resident: ::std::os::raw::c_uint,
    pub pages_shared_now_private: ::std::os::raw::c_uint,
    pub pages_swapped_out: ::std::os::raw::c_uint,
    pub pages_dirtied: ::std::os::raw::c_uint,
    pub ref_count: ::std::os::raw::c_uint,
    pub shadow_depth: ::std::os::raw::c_ushort,
    pub external_pager: ::std::os::raw::c_uchar,
    pub share_mode: ::std::os::raw::c_uchar,
    pub is_submap: boolean_t,
    pub behavior: vm_behavior_t,
    pub object_id: vm32_object_id_t,
    pub user_wired_count: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_vm_region_submap_info() {
    assert_eq!(::std::mem::size_of::<vm_region_submap_info>(),
               60usize,
               concat!("Size of: ", stringify!(vm_region_submap_info)));
    assert_eq!(::std::mem::align_of::<vm_region_submap_info>(),
               4usize,
               concat!("Alignment of ", stringify!(vm_region_submap_info)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_submap_info)).protection as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(protection)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info)).max_protection as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(max_protection)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_submap_info)).inheritance as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(inheritance)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_submap_info)).offset as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(offset)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_submap_info)).user_tag as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(user_tag)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info)).pages_resident as *const _ as usize
               },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(pages_resident)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info)).pages_shared_now_private as *const _ as
                   usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(pages_shared_now_private)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info)).pages_swapped_out as *const _ as usize
               },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(pages_swapped_out)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info)).pages_dirtied as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(pages_dirtied)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_submap_info)).ref_count as *const _ as usize },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(ref_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info)).shadow_depth as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(shadow_depth)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info)).external_pager as *const _ as usize
               },
               42usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(external_pager)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_submap_info)).share_mode as *const _ as usize },
               43usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(share_mode)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_submap_info)).is_submap as *const _ as usize },
               44usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(is_submap)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_submap_info)).behavior as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(behavior)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_submap_info)).object_id as *const _ as usize },
               52usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(object_id)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info)).user_wired_count as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info),
                       "::",
                       stringify!(user_wired_count)));
}
impl Clone for vm_region_submap_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type vm_region_submap_info_t = *mut vm_region_submap_info;
pub type vm_region_submap_info_data_t = vm_region_submap_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_region_submap_info_64 {
    pub protection: vm_prot_t,
    pub max_protection: vm_prot_t,
    pub inheritance: vm_inherit_t,
    pub offset: memory_object_offset_t,
    pub user_tag: ::std::os::raw::c_uint,
    pub pages_resident: ::std::os::raw::c_uint,
    pub pages_shared_now_private: ::std::os::raw::c_uint,
    pub pages_swapped_out: ::std::os::raw::c_uint,
    pub pages_dirtied: ::std::os::raw::c_uint,
    pub ref_count: ::std::os::raw::c_uint,
    pub shadow_depth: ::std::os::raw::c_ushort,
    pub external_pager: ::std::os::raw::c_uchar,
    pub share_mode: ::std::os::raw::c_uchar,
    pub is_submap: boolean_t,
    pub behavior: vm_behavior_t,
    pub object_id: vm32_object_id_t,
    pub user_wired_count: ::std::os::raw::c_ushort,
    pub pages_reusable: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vm_region_submap_info_64() {
    assert_eq!(::std::mem::size_of::<vm_region_submap_info_64>(),
               68usize,
               concat!("Size of: ", stringify!(vm_region_submap_info_64)));
    assert_eq!(::std::mem::align_of::<vm_region_submap_info_64>(),
               4usize,
               concat!("Alignment of ", stringify!(vm_region_submap_info_64)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).protection as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(protection)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).max_protection as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(max_protection)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).inheritance as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(inheritance)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_submap_info_64)).offset as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(offset)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_submap_info_64)).user_tag as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(user_tag)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).pages_resident as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(pages_resident)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).pages_shared_now_private as
                   *const _ as usize
               },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(pages_shared_now_private)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).pages_swapped_out as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(pages_swapped_out)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).pages_dirtied as *const _ as usize
               },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(pages_dirtied)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).ref_count as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(ref_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).shadow_depth as *const _ as usize
               },
               44usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(shadow_depth)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).external_pager as *const _ as usize
               },
               46usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(external_pager)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).share_mode as *const _ as usize
               },
               47usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(share_mode)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).is_submap as *const _ as usize
               },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(is_submap)));
    assert_eq!(unsafe { &(*(0 as *const vm_region_submap_info_64)).behavior as *const _ as usize },
               52usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(behavior)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).object_id as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(object_id)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).user_wired_count as *const _ as usize
               },
               60usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(user_wired_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_info_64)).pages_reusable as *const _ as usize
               },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_info_64),
                       "::",
                       stringify!(pages_reusable)));
}
impl Clone for vm_region_submap_info_64 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type vm_region_submap_info_64_t = *mut vm_region_submap_info_64;
pub type vm_region_submap_info_data_64_t = vm_region_submap_info_64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_region_submap_short_info_64 {
    pub protection: vm_prot_t,
    pub max_protection: vm_prot_t,
    pub inheritance: vm_inherit_t,
    pub offset: memory_object_offset_t,
    pub user_tag: ::std::os::raw::c_uint,
    pub ref_count: ::std::os::raw::c_uint,
    pub shadow_depth: ::std::os::raw::c_ushort,
    pub external_pager: ::std::os::raw::c_uchar,
    pub share_mode: ::std::os::raw::c_uchar,
    pub is_submap: boolean_t,
    pub behavior: vm_behavior_t,
    pub object_id: vm32_object_id_t,
    pub user_wired_count: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_vm_region_submap_short_info_64() {
    assert_eq!(::std::mem::size_of::<vm_region_submap_short_info_64>(),
               48usize,
               concat!("Size of: ", stringify!(vm_region_submap_short_info_64)));
    assert_eq!(::std::mem::align_of::<vm_region_submap_short_info_64>(),
               4usize,
               concat!("Alignment of ", stringify!(vm_region_submap_short_info_64)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_short_info_64)).protection as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_short_info_64),
                       "::",
                       stringify!(protection)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_short_info_64)).max_protection as *const _ as
                   usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_short_info_64),
                       "::",
                       stringify!(max_protection)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_short_info_64)).inheritance as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_short_info_64),
                       "::",
                       stringify!(inheritance)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_short_info_64)).offset as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_short_info_64),
                       "::",
                       stringify!(offset)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_short_info_64)).user_tag as *const _ as usize
               },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_short_info_64),
                       "::",
                       stringify!(user_tag)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_short_info_64)).ref_count as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_short_info_64),
                       "::",
                       stringify!(ref_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_short_info_64)).shadow_depth as *const _ as
                   usize
               },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_short_info_64),
                       "::",
                       stringify!(shadow_depth)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_short_info_64)).external_pager as *const _ as
                   usize
               },
               30usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_short_info_64),
                       "::",
                       stringify!(external_pager)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_short_info_64)).share_mode as *const _ as usize
               },
               31usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_short_info_64),
                       "::",
                       stringify!(share_mode)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_short_info_64)).is_submap as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_short_info_64),
                       "::",
                       stringify!(is_submap)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_short_info_64)).behavior as *const _ as usize
               },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_short_info_64),
                       "::",
                       stringify!(behavior)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_short_info_64)).object_id as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_short_info_64),
                       "::",
                       stringify!(object_id)));
    assert_eq!(unsafe {
                   &(*(0 as *const vm_region_submap_short_info_64)).user_wired_count as *const _ as
                   usize
               },
               44usize,
               concat!("Alignment of field: ",
                       stringify!(vm_region_submap_short_info_64),
                       "::",
                       stringify!(user_wired_count)));
}
impl Clone for vm_region_submap_short_info_64 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type vm_region_submap_short_info_64_t = *mut vm_region_submap_short_info_64;
pub type vm_region_submap_short_info_data_64_t = vm_region_submap_short_info_64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_vm_read_entry {
    pub address: mach_vm_address_t,
    pub size: mach_vm_size_t,
}
#[test]
fn bindgen_test_layout_mach_vm_read_entry() {
    assert_eq!(::std::mem::size_of::<mach_vm_read_entry>(),
               16usize,
               concat!("Size of: ", stringify!(mach_vm_read_entry)));
    assert_eq!(::std::mem::align_of::<mach_vm_read_entry>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_vm_read_entry)));
    assert_eq!(unsafe { &(*(0 as *const mach_vm_read_entry)).address as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_vm_read_entry),
                       "::",
                       stringify!(address)));
    assert_eq!(unsafe { &(*(0 as *const mach_vm_read_entry)).size as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(mach_vm_read_entry),
                       "::",
                       stringify!(size)));
}
impl Clone for mach_vm_read_entry {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_read_entry {
    pub address: vm_address_t,
    pub size: vm_size_t,
}
#[test]
fn bindgen_test_layout_vm_read_entry() {
    assert_eq!(::std::mem::size_of::<vm_read_entry>(),
               16usize,
               concat!("Size of: ", stringify!(vm_read_entry)));
    assert_eq!(::std::mem::align_of::<vm_read_entry>(),
               4usize,
               concat!("Alignment of ", stringify!(vm_read_entry)));
    assert_eq!(unsafe { &(*(0 as *const vm_read_entry)).address as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_read_entry),
                       "::",
                       stringify!(address)));
    assert_eq!(unsafe { &(*(0 as *const vm_read_entry)).size as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(vm_read_entry),
                       "::",
                       stringify!(size)));
}
impl Clone for vm_read_entry {
    fn clone(&self) -> Self {
        *self
    }
}
pub type mach_vm_read_entry_t = [mach_vm_read_entry; 256usize];
pub type vm_read_entry_t = [vm_read_entry; 256usize];
pub type vm_page_info_t = *mut ::std::os::raw::c_int;
pub type vm_page_info_data_t = [::std::os::raw::c_int; 0usize];
pub type vm_page_info_flavor_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vm_page_info_basic {
    pub disposition: ::std::os::raw::c_int,
    pub ref_count: ::std::os::raw::c_int,
    pub object_id: vm_object_id_t,
    pub offset: memory_object_offset_t,
    pub depth: ::std::os::raw::c_int,
    pub __pad: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vm_page_info_basic() {
    assert_eq!(::std::mem::size_of::<vm_page_info_basic>(),
               32usize,
               concat!("Size of: ", stringify!(vm_page_info_basic)));
    assert_eq!(::std::mem::align_of::<vm_page_info_basic>(),
               8usize,
               concat!("Alignment of ", stringify!(vm_page_info_basic)));
    assert_eq!(unsafe { &(*(0 as *const vm_page_info_basic)).disposition as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(vm_page_info_basic),
                       "::",
                       stringify!(disposition)));
    assert_eq!(unsafe { &(*(0 as *const vm_page_info_basic)).ref_count as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(vm_page_info_basic),
                       "::",
                       stringify!(ref_count)));
    assert_eq!(unsafe { &(*(0 as *const vm_page_info_basic)).object_id as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(vm_page_info_basic),
                       "::",
                       stringify!(object_id)));
    assert_eq!(unsafe { &(*(0 as *const vm_page_info_basic)).offset as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(vm_page_info_basic),
                       "::",
                       stringify!(offset)));
    assert_eq!(unsafe { &(*(0 as *const vm_page_info_basic)).depth as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(vm_page_info_basic),
                       "::",
                       stringify!(depth)));
    assert_eq!(unsafe { &(*(0 as *const vm_page_info_basic)).__pad as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(vm_page_info_basic),
                       "::",
                       stringify!(__pad)));
}
impl Clone for vm_page_info_basic {
    fn clone(&self) -> Self {
        *self
    }
}
pub type vm_page_info_basic_t = *mut vm_page_info_basic;
pub type vm_page_info_basic_data_t = vm_page_info_basic;
pub type kmod_t = ::std::os::raw::c_int;
#[repr(C)]
pub struct kmod_info {
    pub next: *mut kmod_info,
    pub info_version: i32,
    pub id: u32,
    pub name: [::std::os::raw::c_char; 64usize],
    pub version: [::std::os::raw::c_char; 64usize],
    pub reference_count: i32,
    pub reference_list: *mut kmod_reference_t,
    pub address: vm_address_t,
    pub size: vm_size_t,
    pub hdr_size: vm_size_t,
    pub start: kmod_start_func_t,
    pub stop: kmod_stop_func_t,
}
#[test]
fn bindgen_test_layout_kmod_info() {
    assert_eq!(::std::mem::size_of::<kmod_info>(),
               196usize,
               concat!("Size of: ", stringify!(kmod_info)));
    assert_eq!(::std::mem::align_of::<kmod_info>(),
               4usize,
               concat!("Alignment of ", stringify!(kmod_info)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info)).next as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info),
                       "::",
                       stringify!(next)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info)).info_version as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info),
                       "::",
                       stringify!(info_version)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info)).id as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info),
                       "::",
                       stringify!(id)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info)).name as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info),
                       "::",
                       stringify!(name)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info)).version as *const _ as usize },
               80usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info),
                       "::",
                       stringify!(version)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info)).reference_count as *const _ as usize },
               144usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info),
                       "::",
                       stringify!(reference_count)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info)).reference_list as *const _ as usize },
               148usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info),
                       "::",
                       stringify!(reference_list)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info)).address as *const _ as usize },
               156usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info),
                       "::",
                       stringify!(address)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info)).size as *const _ as usize },
               164usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info),
                       "::",
                       stringify!(size)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info)).hdr_size as *const _ as usize },
               172usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info),
                       "::",
                       stringify!(hdr_size)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info)).start as *const _ as usize },
               180usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info),
                       "::",
                       stringify!(start)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info)).stop as *const _ as usize },
               188usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info),
                       "::",
                       stringify!(stop)));
}
pub type kmod_start_func_t =
    ::std::option::Option<unsafe extern "C" fn(ki: *mut kmod_info,
                                               data: *mut ::std::os::raw::c_void)
                                               -> kern_return_t>;
pub type kmod_stop_func_t =
    ::std::option::Option<unsafe extern "C" fn(ki: *mut kmod_info,
                                               data: *mut ::std::os::raw::c_void)
                                               -> kern_return_t>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kmod_reference {
    pub next: *mut kmod_reference,
    pub info: *mut kmod_info,
}
#[test]
fn bindgen_test_layout_kmod_reference() {
    assert_eq!(::std::mem::size_of::<kmod_reference>(),
               16usize,
               concat!("Size of: ", stringify!(kmod_reference)));
    assert_eq!(::std::mem::align_of::<kmod_reference>(),
               4usize,
               concat!("Alignment of ", stringify!(kmod_reference)));
    assert_eq!(unsafe { &(*(0 as *const kmod_reference)).next as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_reference),
                       "::",
                       stringify!(next)));
    assert_eq!(unsafe { &(*(0 as *const kmod_reference)).info as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_reference),
                       "::",
                       stringify!(info)));
}
impl Clone for kmod_reference {
    fn clone(&self) -> Self {
        *self
    }
}
pub type kmod_reference_t = kmod_reference;
pub type kmod_info_t = kmod_info;
#[repr(C)]
pub struct kmod_info_32_v1 {
    pub next_addr: u32,
    pub info_version: i32,
    pub id: u32,
    pub name: [u8; 64usize],
    pub version: [u8; 64usize],
    pub reference_count: i32,
    pub reference_list_addr: u32,
    pub address: u32,
    pub size: u32,
    pub hdr_size: u32,
    pub start_addr: u32,
    pub stop_addr: u32,
}
#[test]
fn bindgen_test_layout_kmod_info_32_v1() {
    assert_eq!(::std::mem::size_of::<kmod_info_32_v1>(),
               168usize,
               concat!("Size of: ", stringify!(kmod_info_32_v1)));
    assert_eq!(::std::mem::align_of::<kmod_info_32_v1>(),
               4usize,
               concat!("Alignment of ", stringify!(kmod_info_32_v1)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_32_v1)).next_addr as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_32_v1),
                       "::",
                       stringify!(next_addr)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_32_v1)).info_version as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_32_v1),
                       "::",
                       stringify!(info_version)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_32_v1)).id as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_32_v1),
                       "::",
                       stringify!(id)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_32_v1)).name as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_32_v1),
                       "::",
                       stringify!(name)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_32_v1)).version as *const _ as usize },
               76usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_32_v1),
                       "::",
                       stringify!(version)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_32_v1)).reference_count as *const _ as usize },
               140usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_32_v1),
                       "::",
                       stringify!(reference_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const kmod_info_32_v1)).reference_list_addr as *const _ as usize
               },
               144usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_32_v1),
                       "::",
                       stringify!(reference_list_addr)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_32_v1)).address as *const _ as usize },
               148usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_32_v1),
                       "::",
                       stringify!(address)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_32_v1)).size as *const _ as usize },
               152usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_32_v1),
                       "::",
                       stringify!(size)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_32_v1)).hdr_size as *const _ as usize },
               156usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_32_v1),
                       "::",
                       stringify!(hdr_size)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_32_v1)).start_addr as *const _ as usize },
               160usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_32_v1),
                       "::",
                       stringify!(start_addr)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_32_v1)).stop_addr as *const _ as usize },
               164usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_32_v1),
                       "::",
                       stringify!(stop_addr)));
}
pub type kmod_info_32_v1_t = kmod_info_32_v1;
#[repr(C)]
pub struct kmod_info_64_v1 {
    pub next_addr: u64,
    pub info_version: i32,
    pub id: u32,
    pub name: [u8; 64usize],
    pub version: [u8; 64usize],
    pub reference_count: i32,
    pub reference_list_addr: u64,
    pub address: u64,
    pub size: u64,
    pub hdr_size: u64,
    pub start_addr: u64,
    pub stop_addr: u64,
}
#[test]
fn bindgen_test_layout_kmod_info_64_v1() {
    assert_eq!(::std::mem::size_of::<kmod_info_64_v1>(),
               196usize,
               concat!("Size of: ", stringify!(kmod_info_64_v1)));
    assert_eq!(::std::mem::align_of::<kmod_info_64_v1>(),
               4usize,
               concat!("Alignment of ", stringify!(kmod_info_64_v1)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_64_v1)).next_addr as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_64_v1),
                       "::",
                       stringify!(next_addr)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_64_v1)).info_version as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_64_v1),
                       "::",
                       stringify!(info_version)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_64_v1)).id as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_64_v1),
                       "::",
                       stringify!(id)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_64_v1)).name as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_64_v1),
                       "::",
                       stringify!(name)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_64_v1)).version as *const _ as usize },
               80usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_64_v1),
                       "::",
                       stringify!(version)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_64_v1)).reference_count as *const _ as usize },
               144usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_64_v1),
                       "::",
                       stringify!(reference_count)));
    assert_eq!(unsafe {
                   &(*(0 as *const kmod_info_64_v1)).reference_list_addr as *const _ as usize
               },
               148usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_64_v1),
                       "::",
                       stringify!(reference_list_addr)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_64_v1)).address as *const _ as usize },
               156usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_64_v1),
                       "::",
                       stringify!(address)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_64_v1)).size as *const _ as usize },
               164usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_64_v1),
                       "::",
                       stringify!(size)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_64_v1)).hdr_size as *const _ as usize },
               172usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_64_v1),
                       "::",
                       stringify!(hdr_size)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_64_v1)).start_addr as *const _ as usize },
               180usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_64_v1),
                       "::",
                       stringify!(start_addr)));
    assert_eq!(unsafe { &(*(0 as *const kmod_info_64_v1)).stop_addr as *const _ as usize },
               188usize,
               concat!("Alignment of field: ",
                       stringify!(kmod_info_64_v1),
                       "::",
                       stringify!(stop_addr)));
}
pub type kmod_info_64_v1_t = kmod_info_64_v1;
pub type kmod_args_t = *mut ::std::os::raw::c_void;
pub type kmod_control_flavor_t = ::std::os::raw::c_int;
pub type kmod_info_array_t = *mut kmod_info_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fsid {
    pub val: [i32; 2usize],
}
#[test]
fn bindgen_test_layout_fsid() {
    assert_eq!(::std::mem::size_of::<fsid>(),
               8usize,
               concat!("Size of: ", stringify!(fsid)));
    assert_eq!(::std::mem::align_of::<fsid>(),
               4usize,
               concat!("Alignment of ", stringify!(fsid)));
    assert_eq!(unsafe { &(*(0 as *const fsid)).val as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(fsid),
                       "::",
                       stringify!(val)));
}
impl Clone for fsid {
    fn clone(&self) -> Self {
        *self
    }
}
pub type fsid_t = fsid;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fsobj_id {
    pub fid_objno: u_int32_t,
    pub fid_generation: u_int32_t,
}
#[test]
fn bindgen_test_layout_fsobj_id() {
    assert_eq!(::std::mem::size_of::<fsobj_id>(),
               8usize,
               concat!("Size of: ", stringify!(fsobj_id)));
    assert_eq!(::std::mem::align_of::<fsobj_id>(),
               4usize,
               concat!("Alignment of ", stringify!(fsobj_id)));
    assert_eq!(unsafe { &(*(0 as *const fsobj_id)).fid_objno as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(fsobj_id),
                       "::",
                       stringify!(fid_objno)));
    assert_eq!(unsafe { &(*(0 as *const fsobj_id)).fid_generation as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(fsobj_id),
                       "::",
                       stringify!(fid_generation)));
}
impl Clone for fsobj_id {
    fn clone(&self) -> Self {
        *self
    }
}
pub type fsobj_id_t = fsobj_id;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dyld_kernel_image_info {
    pub uuid: uuid_t,
    pub fsobjid: fsobj_id_t,
    pub fsid: fsid_t,
    pub load_addr: u64,
}
#[test]
fn bindgen_test_layout_dyld_kernel_image_info() {
    assert_eq!(::std::mem::size_of::<dyld_kernel_image_info>(),
               40usize,
               concat!("Size of: ", stringify!(dyld_kernel_image_info)));
    assert_eq!(::std::mem::align_of::<dyld_kernel_image_info>(),
               8usize,
               concat!("Alignment of ", stringify!(dyld_kernel_image_info)));
    assert_eq!(unsafe { &(*(0 as *const dyld_kernel_image_info)).uuid as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(dyld_kernel_image_info),
                       "::",
                       stringify!(uuid)));
    assert_eq!(unsafe { &(*(0 as *const dyld_kernel_image_info)).fsobjid as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(dyld_kernel_image_info),
                       "::",
                       stringify!(fsobjid)));
    assert_eq!(unsafe { &(*(0 as *const dyld_kernel_image_info)).fsid as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(dyld_kernel_image_info),
                       "::",
                       stringify!(fsid)));
    assert_eq!(unsafe { &(*(0 as *const dyld_kernel_image_info)).load_addr as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(dyld_kernel_image_info),
                       "::",
                       stringify!(load_addr)));
}
impl Clone for dyld_kernel_image_info {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dyld_kernel_process_info {
    pub cache_image_info: dyld_kernel_image_info,
    pub timestamp: u64,
    pub imageCount: u32,
    pub initialImageCount: u32,
    pub dyldState: u8,
    pub no_cache: boolean_t,
    pub private_cache: boolean_t,
}
#[test]
fn bindgen_test_layout_dyld_kernel_process_info() {
    assert_eq!(::std::mem::size_of::<dyld_kernel_process_info>(),
               72usize,
               concat!("Size of: ", stringify!(dyld_kernel_process_info)));
    assert_eq!(::std::mem::align_of::<dyld_kernel_process_info>(),
               8usize,
               concat!("Alignment of ", stringify!(dyld_kernel_process_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const dyld_kernel_process_info)).cache_image_info as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(dyld_kernel_process_info),
                       "::",
                       stringify!(cache_image_info)));
    assert_eq!(unsafe {
                   &(*(0 as *const dyld_kernel_process_info)).timestamp as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(dyld_kernel_process_info),
                       "::",
                       stringify!(timestamp)));
    assert_eq!(unsafe {
                   &(*(0 as *const dyld_kernel_process_info)).imageCount as *const _ as usize
               },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(dyld_kernel_process_info),
                       "::",
                       stringify!(imageCount)));
    assert_eq!(unsafe {
                   &(*(0 as *const dyld_kernel_process_info)).initialImageCount as *const _ as usize
               },
               52usize,
               concat!("Alignment of field: ",
                       stringify!(dyld_kernel_process_info),
                       "::",
                       stringify!(initialImageCount)));
    assert_eq!(unsafe {
                   &(*(0 as *const dyld_kernel_process_info)).dyldState as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(dyld_kernel_process_info),
                       "::",
                       stringify!(dyldState)));
    assert_eq!(unsafe { &(*(0 as *const dyld_kernel_process_info)).no_cache as *const _ as usize },
               60usize,
               concat!("Alignment of field: ",
                       stringify!(dyld_kernel_process_info),
                       "::",
                       stringify!(no_cache)));
    assert_eq!(unsafe {
                   &(*(0 as *const dyld_kernel_process_info)).private_cache as *const _ as usize
               },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(dyld_kernel_process_info),
                       "::",
                       stringify!(private_cache)));
}
impl Clone for dyld_kernel_process_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type dyld_kernel_image_info_t = dyld_kernel_image_info;
pub type dyld_kernel_process_info_t = dyld_kernel_process_info;
pub type dyld_kernel_image_info_array_t = *mut dyld_kernel_image_info_t;
pub type task_t = mach_port_t;
pub type task_name_t = mach_port_t;
pub type task_inspect_t = mach_port_t;
pub type task_suspension_token_t = mach_port_t;
pub type thread_t = mach_port_t;
pub type thread_act_t = mach_port_t;
pub type thread_inspect_t = mach_port_t;
pub type ipc_space_t = mach_port_t;
pub type ipc_space_inspect_t = mach_port_t;
pub type coalition_t = mach_port_t;
pub type host_t = mach_port_t;
pub type host_priv_t = mach_port_t;
pub type host_security_t = mach_port_t;
pub type processor_t = mach_port_t;
pub type processor_set_t = mach_port_t;
pub type processor_set_control_t = mach_port_t;
pub type semaphore_t = mach_port_t;
pub type lock_set_t = mach_port_t;
pub type ledger_t = mach_port_t;
pub type alarm_t = mach_port_t;
pub type clock_serv_t = mach_port_t;
pub type clock_ctrl_t = mach_port_t;
pub type processor_set_name_t = processor_set_t;
pub type clock_reply_t = mach_port_t;
pub type bootstrap_t = mach_port_t;
pub type mem_entry_name_port_t = mach_port_t;
pub type exception_handler_t = mach_port_t;
pub type exception_handler_array_t = *mut exception_handler_t;
pub type vm_task_entry_t = mach_port_t;
pub type io_master_t = mach_port_t;
pub type UNDServerRef = mach_port_t;
pub type task_array_t = *mut task_t;
pub type thread_array_t = *mut thread_t;
pub type processor_set_array_t = *mut processor_set_t;
pub type processor_set_name_array_t = *mut processor_set_t;
pub type processor_array_t = *mut processor_t;
pub type thread_act_array_t = *mut thread_act_t;
pub type ledger_array_t = *mut ledger_t;
pub type task_port_t = task_t;
pub type task_port_array_t = task_array_t;
pub type thread_port_t = thread_t;
pub type thread_port_array_t = thread_array_t;
pub type ipc_space_port_t = ipc_space_t;
pub type host_name_t = host_t;
pub type host_name_port_t = host_t;
pub type processor_set_port_t = processor_set_t;
pub type processor_set_name_port_t = processor_set_t;
pub type processor_set_name_port_array_t = processor_set_array_t;
pub type processor_set_control_port_t = processor_set_t;
pub type processor_port_t = processor_t;
pub type processor_port_array_t = processor_array_t;
pub type thread_act_port_t = thread_act_t;
pub type thread_act_port_array_t = thread_act_array_t;
pub type semaphore_port_t = semaphore_t;
pub type lock_set_port_t = lock_set_t;
pub type ledger_port_t = ledger_t;
pub type ledger_port_array_t = ledger_array_t;
pub type alarm_port_t = alarm_t;
pub type clock_serv_port_t = clock_serv_t;
pub type clock_ctrl_port_t = clock_ctrl_t;
pub type exception_port_t = exception_handler_t;
pub type exception_port_arrary_t = exception_handler_array_t;
pub type ledger_item_t = natural_t;
pub type ledger_amount_t = i64;
pub type emulation_vector_t = *mut mach_vm_offset_t;
pub type user_subsystem_t = *mut ::std::os::raw::c_char;
pub type labelstr_t = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mach_timebase_info {
    pub numer: u32,
    pub denom: u32,
}
#[test]
fn bindgen_test_layout_mach_timebase_info() {
    assert_eq!(::std::mem::size_of::<mach_timebase_info>(),
               8usize,
               concat!("Size of: ", stringify!(mach_timebase_info)));
    assert_eq!(::std::mem::align_of::<mach_timebase_info>(),
               4usize,
               concat!("Alignment of ", stringify!(mach_timebase_info)));
    assert_eq!(unsafe { &(*(0 as *const mach_timebase_info)).numer as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(mach_timebase_info),
                       "::",
                       stringify!(numer)));
    assert_eq!(unsafe { &(*(0 as *const mach_timebase_info)).denom as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(mach_timebase_info),
                       "::",
                       stringify!(denom)));
}
impl Clone for mach_timebase_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type mach_timebase_info_t = *mut mach_timebase_info;
pub type mach_timebase_info_data_t = mach_timebase_info;
extern "C" {
    pub fn mach_timebase_info(info: mach_timebase_info_t) -> kern_return_t;
}
extern "C" {
    pub fn mach_wait_until(deadline: u64) -> kern_return_t;
}
extern "C" {
    pub fn mach_absolute_time() -> u64;
}
extern "C" {
    pub fn mach_approximate_time() -> u64;
}
extern "C" {
    pub fn mach_continuous_time() -> u64;
}
extern "C" {
    pub fn mach_continuous_approximate_time() -> u64;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>(),
               24usize,
               concat!("Size of: ", stringify!(__va_list_tag)));
    assert_eq!(::std::mem::align_of::<__va_list_tag>(),
               8usize,
               concat!("Alignment of ", stringify!(__va_list_tag)));
    assert_eq!(unsafe { &(*(0 as *const __va_list_tag)).gp_offset as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__va_list_tag),
                       "::",
                       stringify!(gp_offset)));
    assert_eq!(unsafe { &(*(0 as *const __va_list_tag)).fp_offset as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(__va_list_tag),
                       "::",
                       stringify!(fp_offset)));
    assert_eq!(unsafe { &(*(0 as *const __va_list_tag)).overflow_arg_area as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__va_list_tag),
                       "::",
                       stringify!(overflow_arg_area)));
    assert_eq!(unsafe { &(*(0 as *const __va_list_tag)).reg_save_area as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(__va_list_tag),
                       "::",
                       stringify!(reg_save_area)));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self {
        *self
    }
}
